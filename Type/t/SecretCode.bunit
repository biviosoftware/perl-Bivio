# Copyright (c) 2025 bivio Software, Inc.  All Rights Reserved.
Unit();
config({
    class() => {
        password_query_expiry_seconds => 30,
        password_mfa_challenge_expiry_seconds => 20,
        password_reset_expiry_seconds => 10,
    },
});
Type_DateTime()->set_test_now(now());
my($o) = {map(($_->get_name => $_), class()->get_non_zero_list)};
my($non_mfa) = {%$o};
delete($non_mfa->{MFA_RECOVERY});
[
    map({
        my($t) = $_;
        sub {$o->{$t->[0]}} => [
            from_literal_for_type => [
                [$t->[1]] => $t->[2],
            ],
        ];
    } (
        [qw(MFA_RECOVERY foo.bar.baz foo-bar-baz)],
        map([$_, qw(foo.bar.baz foo.bar.baz)], keys(%$non_mfa)),
    )),
    map({
        my($t) = $_;
        sub {$o->{$t->[0]}} => [
            generate_code_for_type => $t->[1],
        ];
    } (
        ['MFA_RECOVERY', qr/^([a-z]+-)+[a-z]+$/],
        map([$_, qr/^.{16}$/], keys(%$non_mfa)),
    )),
    map({
        my($t) = $_;
        {
            object => sub {$o->{$t->[0]}},
            compute_return => sub {
                my(undef, $actual) = @_;
                return $actual
                    unless defined($actual->[0]);
                return [Type_DateTime()->diff_seconds($actual->[0], now())];
            },
        } => [
            get_expiry_for_type => $t->[1],
        ];
    } (
        [MFA_RECOVERY => undef],
        [PASSWORD_QUERY => 30],
        [PASSWORD_MFA_CHALLENGE => 20],
        [PASSWORD_RESET => 10]
    )),
];
