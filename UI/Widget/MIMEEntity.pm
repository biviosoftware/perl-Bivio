# Copyright (c) 2003 bivio Software, Inc.  All Rights Reserved.
# $Id$
package Bivio::UI::Widget::MIMEEntity;
use strict;
$Bivio::UI::Widget::MIMEEntity::VERSION = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);
$_ = $Bivio::UI::Widget::MIMEEntity::VERSION;

=head1 NAME

Bivio::UI::Widget::MIMEEntity - create a MIME entity from parts generated by widgets

=head1 RELEASE SCOPE

bOP

=head1 SYNOPSIS

    use Bivio::UI::Widget::MIMEEntity;

=cut

=head1 EXTENDS

L<Bivio::UI::Widget::Join>

=cut

use Bivio::UI::Widget::Join;
@Bivio::UI::Widget::MIMEEntity::ISA = ('Bivio::UI::Widget::Join');

=head1 DESCRIPTION

C<Bivio::UI::Widget::MIMEEntity>

=cut

#=IMPORTS
use MIME::Entity ();

#=VARIABLES

=head1 METHODS

=cut

=for html <a name="headers_as_string"></a>

=head2 headers_as_string(any source) : string

Return MIME headers as string.  B<Must call L<render|"render"> before calling
this routine>, and returns the last rendered value put on the request.

=cut

sub headers_as_string {
    my($self, $source) = @_;
    return $source->get_request->get("$self.headers");
}

=for html <a name="initialize"></a>

=head2 initialize() 

Initializes mime_type and mime_encoding if not already set.

=cut

sub initialize {
    my($self) = @_;
    foreach my $x (
	[mime_type => 'multipart/mixed'],
	[mime_encoding => '7bit'],
    ) {
	$self->get_if_exists_else_put(@$x);
    }
    return shift->SUPER::initialize(@_);
}

=for html <a name="render"></a>

=head2 render(Bivio::UI::WidgetValueSource source, string_ref buffer)

Renders this instance into I<buffer> using I<source> to evaluate
widget values.  Saves mime headers on the request.

=cut

sub render {
    my($self, $source, $buffer) = @_;
    my($name) = 0;
    my($entity) = MIME::Entity->build(
        map({
	    ($_ => ${$self->render_attr('mime_' . lc($_), $source)});
	} qw(Type Encoding)),
    );
    foreach my $v (@{$self->get('values')}) {
	my($e);
	if (UNIVERSAL::isa($v, 'Bivio::UI::HTML::Widget::FileAttachment')) {
	    $entity->attach(
	        Path => ${$v->render_attr('path', $source)},
                Disposition => 'attachment',
	    map({
		($_ => ${$v->render_attr('mime_' . lc($_), $source)});
	    } qw(Type Encoding)),
        );} else {
            $entity->attach(
	        Data => ${$self->render_value($name++, $v, $source)},
	        map({
		    ($_ => ${$v->render_attr('mime_' . lc($_), $source)});
	        } qw(Type Encoding)),
	    );
        }
    }
    $$buffer .= $entity->body_as_string;
    $source->get_request->put(
	"$self.headers" => join('',
	    map({
		$_ . ': ', $entity->head->get(lc($_));
	    } 'MIME-Version', 'Content-Type', 'Content-Transfer-Encoding'),
	),
    );
    return;
}

#=PRIVATE SUBROUTINES

=head1 COPYRIGHT

Copyright (c) 2003 bivio Software, Inc.  All Rights Reserved.

=head1 VERSION

$Id$

=cut

1;

__END__

sub render {
    my($self, $source, $buffer) = @_;
    my($name) = 0;
    my($entity) = MIME::Entity->new;
    foreach my $v (@{$self->get('values')}) {
        next if $v->can('want_render') && !$v->want_render($source);
	my($data) = '';
	$v->render($source, \$data);
        $self->die($v, ': empty mime part')
	    unless length($data);
	$entity->attach({
	        Data => $data,
	        map({
		     my($x) = '';
		     ($_ => $v->unsafe_render_attr('mime_' . lc($_), $source, \$x) => $x : $_DEFAULT->{$_});
	        } qw(Type Encoding)),
        });
    );
    if ($self->has_keys('mime_type')) {
	map({
	    ($_ => ${$self->render_attr('mime_' . lc($_), $source)});
	} qw(Type Encoding));
    }
    else {
        if (scalar($entity->parts) == 1) {
            $entity->make_singlepart;
        else {
             $entity->make_multipart;
        }
    }
    $$buffer .= $entity->body_as_string;
    $source->get_request->put(
	"$self.headers" => join('',
	    map({
		$_ . ': ', $entity->head->get(lc($_));
	    } 'MIME-Version', 'Content-Type', 'Content-Transfer-Encoding'),
	),
    );
    return;
}
