# Copyright (c) 2025 bivio Software, Inc.  All Rights Reserved.
my($secret);
my($recovery_codes);
my($time_step);
my($next_time_step) = sub {
    my($seconds) = @_;
    $seconds //= Model_UserTOTP()->get_default_period;
    Type_DateTime()->set_test_now(Type_DateTime()->add_seconds(Type_DateTime()->now, $seconds));
    return $time_step = Biz_RFC6238()->get_time_step(
        Type_DateTime()->to_unix(Type_DateTime()->now), Model_UserTOTP()->get_default_period);
};
my($totp_code);
my($compute_totp_code) = sub {
    return $totp_code = Biz_RFC6238()->compute(
        Model_UserTOTP()->get_default_algorithm,
        Model_UserTOTP()->get_default_digits,
        $secret,
        $time_step,
    );
};
my($no_challenge) = 1;
my($user);
FormModel({
    setup_request => sub {
        return
            if $no_challenge;
        # TODO: this might not be exactly right, but the redirect in execute_assert_login
        # gets ignored by test request.
        return
            if $user->is_locked_out;
        Action_MFAChallenge()
            ->create_challenge(req(), $user, Type_SecretCode()->LOGIN_CHALLENGE)
            ->update({status => Type_SecretCodeStatus()->PASSED});
        Action_MFAChallenge()->execute_assert_login(req());
        return;
    },
});
config({
    'Bivio::Biz::Model::LoginAttempt' => {
        locked_out_failure_count => 2,
    },
});
$next_time_step->(0);
$user = create_user(random_realm_name());
$secret = Type_TOTPSecret()->generate_secret(Model_UserTOTP()->get_default_algorithm);
Action_MFARecoveryCodeList()->execute_preview(req());
$recovery_codes = req(qw(Action.MFARecoveryCodeList mfa_recovery_code_array));
Action_MFAChallenge()->execute_assert_escalation(req());
model('UserEscalationPlainForm')->process({});
Model_UserEnableTOTPForm()->process({
    totp_secret => $secret,
    mfa_recovery_code_array => $recovery_codes,
    totp_code => $compute_totp_code->(),
    totp_time_step => $time_step,
});
commit();
my($set_cookie) = sub {
    req()->set_user_state_and_cookie(Type_UserState()->LOGGED_OUT, $user->get('realm_id'), 1);
    return;
};
[
    [] => FORBIDDEN(),
    inline_case($set_cookie),
    [] => FORBIDDEN(),
    inline_case(sub {$no_challenge = 0}),
    error_case({} => {
        totp_code => 'NULL',
    }),
    error_case({
        totp_code => '123456',
    } => {
        totp_code => 'INVALID_TOTP_CODE',
    }),
    inline_commit(),
    [{
        totp_code => '123456',
    }] => sub {req('task_id')->eq_general_user_locked_out},
    inline_commit(),
    [] => FORBIDDEN(),
    inline_case(sub {
        req()->with_realm_and_user($user, $user, sub {
            # Have to advance the clock or the failure and reset login attempts will have same dt
            # and the login attempt sorting may be incorrect, causing the user to still be locked out.
            Type_DateTime()->set_test_now(Type_DateTime()->add_seconds(Type_DateTime()->now, 1));
            Util_RealmAdmin()->reset_login_attempts;
            Util_RealmAdmin()->reset_password('password');
        });
    }),
    inline_commit(),
    inline_case($set_cookie),
    error_case({
        # Can't use same code as in create.
        totp_code => $compute_totp_code,
    } => {
        totp_code => 'INVALID_TOTP_CODE',
    }),
    inline_case($next_time_step),
    [{
        totp_code => $compute_totp_code,
    }] => sub {
        return 0
            unless req('cookie', class()->TOTP_CODE_FIELD) eq $totp_code;
        return 0
            unless req('cookie', class()->TOTP_TIME_STEP_FIELD) == $time_step;
        return 0
            unless req('user_state')->eq_logged_in;
        return 1;
    },
    [{
        mfa_recovery_code => sub {$recovery_codes->get_element(0)},
    }] => sub {
        return 0
            unless req('cookie', class()->MFA_RECOVERY_CODE_FIELD) eq $recovery_codes->get_element(0);
        return 0
            unless req('user_state')->eq_logged_in;
        return 1;
    },
    error_case({
        # Can't reuse recovery codes.
        mfa_recovery_code => sub {$recovery_codes->get_element(0)},
    } => {
        mfa_recovery_code => 'INVALID_MFA_RECOVERY_CODE',
    }),
    [{
        mfa_recovery_code => sub {$recovery_codes->get_element(1)},
    }] => sub {
        return 0
            unless req('cookie', class()->MFA_RECOVERY_CODE_FIELD) eq $recovery_codes->get_element(1);
        return 0
            unless req('user_state')->eq_logged_in;
        return 1;
    },
];
