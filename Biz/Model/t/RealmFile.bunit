# Copyright (c) 2005 bivio Software, Inc.  All Rights Reserved.
# $Id$
Request('initialize_fully');
set_realm_and_user('root', 'root');
my($a) = sub {
    my($p, $ro, $oro) = @_;
    return {
	defined($p) ? (path => '/RealmFile/' . $p) : (),
	defined($ro) ? (is_read_only => $ro) : (),
	defined($oro) ? (override_is_read_only => $oro) : (),
    };
};
my($dt) = 'Bivio::Type::DateTime';
my($commit) = sub {commit(); return 1};
my($old_mtime) = {modified_date_time => $dt->add_days($dt->now, -1)};
my($new_mtime) = sub {
    my(undef, $actual) = @_;
    die($actual->[0], ': modified_date_time is wrong')
	if $dt->diff_seconds($dt->now, $actual->[0]) > 5;
    return 1;
};
[
#Tests: delete: existing, not existing, not existing and not existing parent (doesn't create parent, delete loaded, delete with args, delete loaded with args, delete read only, public, read only with override, delete with auth_id and without auth_id, not empty folder, empty folder
#Tests: copy from one realm to another, simple file, to dest without parent, to dest with parent, to is_public parent, to is_read_only parent w/o override, with override,  to parent writable but child not writable, w/override
#Tests: update read only w/o override, w/override
    [req()] => [
	parse_path => [
	    '' => '/',
	    '0' => '/0',
	    '?' => CORRUPT_QUERY(),
	],
	# basic CRUD tests; First clean up from possibly bad test run
	delete_deep => [
	    [$a->('/', undef, 1)] => $commit,
	],
	unsafe_load => [
	    [$a->('/')] => 0,
	],
        create_with_content => [
	    [$a->('f1'), \('f1')] => $commit,
	],
	is_empty => 1,
	unsafe_load => [
	    [$a->('f1')] => 1,
	],
	get_content_length => 2,
	get_content => [
	    [] => [\('f1')],
	],
	update_with_content => [
	    [{}, \('f1-update')] => $commit,
	],
	get_content => [
	    [] => [\('f1-update')],
	],
	load => [
	    [$a->('f1')] => not_die(),
	],
	get_content => [
	    [] => [\('f1-update')],
	],
	delete => $commit,
	unsafe_load => [
	    [$a->('f1')] => 0,
	],
        create_with_content => [
	    [$a->('f1'), \('f1')] => $commit,
	    [$a->('f2'), \('f2')] => $commit,
	    [$a->('f2'), \('f2')] => DB_CONSTRAINT(),
	],
	unsafe_load => [
	    [$a->('f1')] => 1,
	    [$a->('f2')] => 1,
	    [{path => '/'}] => 1,
	],
	create_folder => [
	    [$a->('d2/d3')] => not_die(),
	],
	load => [
	    [{path => '/'}] => not_die(),
	],
	update => [
	    [$old_mtime] => $commit,
	],
	delete_deep => [
	    [$a->('/')] => sub {commit(); return [5]},
	],
	load => [
	    [{path => '/'}] => not_die(),
	],
	get => [
	    modified_date_time => $new_mtime,
	],
	unsafe_load => [
	    [$a->('f1')] => 0,
	    [$a->('f2')] => 0,
	],
        create_with_content => [
	    [$a->('f1'), \('f1')] => $commit,
	],
	get_content_type => 'application/octet-stream',
	get_handle => sub {
	    my($case, $actual) = @_;
	    return $actual->[0]->getline eq 'f1' ? 1 : 0;
	},
	create_folder => [
	    [$a->('d1')] => $commit,
	],
	update => [
	    [$old_mtime] => $commit,
	],
	load => [
	    [$a->('f1')] => not_die(),
	],
	update => [
	    [$a->('new1/f1')] => $commit,
	],
	map((
	    load => [
		[$a->($_)] => not_die(),
	    ],
	    update => [
		[$old_mtime] => $commit,
	    ]),
	    qw(new1 d1),
	),
	load => [
	    [$a->('new1/F1')] => not_die(),
	],
	update => [
	    [{is_public => 1}] => not_die(),
	],
	map((
	    load => [
		[$a->($_)] => not_die(),
	    ],
	    get => [
		modified_date_time => $old_mtime->{modified_date_time},
	    ]),
	    qw(new1 d1),
	),
	load => [
	    [$a->('new1/F1')] => not_die(),
	],
	update => [
	    [$a->('d1/F1')] => $commit,
	],
	map((
	    load => [
		[$a->($_)] => not_die(),
	    ],
	    get => [
		modified_date_time => $new_mtime,
	    ]),
	    qw(new1 d1),
	),
	load => [
	    [$a->('d1/f1')] => not_die(),
	],
	get => [
	    path => $a->('d1/F1')->{path},
	],
	get_content => [
	    [] => [\('f1')],
	],
        create_with_content => [
	    [$a->('d1/d2/f3'), \('f3')] => $commit,
	],
	load => [
	    [$a->('d1/d2/f3')] => not_die(),
	],
	get_content => [
	   [] => [\('f3')],
	],
	create_folder => [
	    [$a->('d1/d2/d3')] => $commit,
	],
	is_empty => 1,
	load => [
	    [$a->('D1')] => not_die(),
	],
	is_empty => 0,
	update => [
	    [$a->('/d1-update')] => $commit,
	],
	load => [
	    map(([$a->("/d1-update/$_")] => not_die()), qw(f1 d2 d2/d3 d2/f3), ''),
	],
	copy_deep => [
	    [$a->('/d1-copy')] => $commit,
	],
	load => [
	    [$a->('/d1-copy')] => not_die(),
	],
	load => [
	    map(([$a->("/d1-copy/$_")] => not_die()), '', qw(f1 d2 d2/d3 d2/f3)),
	],
	get_content => [
	    [] => [\('f3')],
	],
	copy_deep => [
	    [$a->('f3-copy')] => $commit,
	],
	load => [
	    [$a->('f3-copy')] => not_die(),
	],
	get_content => [
	    [] => [\('f3')],
	],
	copy_deep => [
	    [$a->('f3-copy')] => not_die(),
	],
	delete_deep => $commit,
	load => [
	    [$a->('f3-copy')] => MODEL_NOT_FOUND(),
	],
	load => [
	    [$a->('d1-copy')] => not_die(),
	],
	delete_deep => $commit,
	load => [
	    map(([$a->("/d1-copy/$_")] => MODEL_NOT_FOUND()),
		'', qw(d2 d2/f3 d2/d3)),
	],
	# Read-only tests
	load => [
	    [{path => '/'}] => not_die(),
	],
	update => [
	    [$old_mtime] => $commit,
	],
	create_folder => [
	    [$a->('ro1', 1)] => $commit,
	],
	get => [
	    is_public => 0,
	    is_read_only => 1,
	],
	load => [
	    [{path => '/'}] => not_die(),
	],
	get => [
	    modified_date_time => $old_mtime->{modified_date_time},
	],
	create_with_content => [
	    [$a->('ro1/f1', undef, 1), \('ro1/f1')] => $commit,
	    [$a->('ro1/d2/f3', undef, 1), \('ro1/d2/f3')] => $commit,
	],
	get => [
	    is_public => 0,
	    is_read_only => 1,
	],
	delete => [
	    [] => FORBIDDEN(),
	],
	delete_deep => [
	    [$a->('ro1/d2', undef, 1)] => $commit,
	],
	load => [
	    [$a->('ro1/d2/f3')] => MODEL_NOT_FOUND(),
	    [$a->('ro1')] => not_die(),
	],
	copy_deep => [
	    [$a->('d1')] => $commit,
	    [$a->('ro2', 1)] => $commit,
	],
	map((
	    load => [
		[$a->($_)] => not_die(),
	    ],
	    get => [
		is_read_only => $_ =~ /ro2/ ? 1 : 0,
		is_public => 0,
	    ],
	    $_ =~ /f1/ ? (
		get_content => [
		    [] => [\('ro1/f1')],
		]
	    ) : ()),
	    qw(d1 d1/f1 ro2 ro2/f1),
	),
	delete_deep => [
	    [$a->('d1')] => $commit,
	    [$a->('ro2/f1')] => FORBIDDEN(),
	    [$a->('ro2', undef, 1)] => $commit,
	],
	load => [
	    [$a->('ro1')] => not_die(),
	],
	update => [
	    [$a->('ro1-update')] => FORBIDDEN(),
# Recursive update of is_read_only and is_public?
	    [$a->('ro1-update', 0, 1)] => not_die(),
	],
 	load => [
 	    [$a->('ro1-update/f1')] => not_die(),
 	],
# This tests non-recursive update of is_read_only
	delete => FORBIDDEN(),
	load => [
	    [$a->('ro1-update')] => not_die(),
	],
	delete_deep => FORBIDDEN(),
	load => [
	    [$a->('ro1-update/f1')] => not_die(),
	],
	update => [
	    [$a->(undef, 0, 1)] => not_die(),
	],
	load => [
	    [$a->('ro1-update')] => not_die(),
	],
	delete_deep => not_die(),
    ],
    class() => [
	delete_all => [
	    [{path => '/'}] => DIE(),
	    # Don't commit, since we don't know what other files need to
	    # be there.
	    [{realm_id => req()->get('auth_id')}] => not_die(),
	],
    ],
];
