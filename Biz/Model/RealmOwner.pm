# Copyright (c) 1999-2001 bivio Inc.  All rights reserved.
# $Id$
# Generated by ../generate.PL on Wed Aug 18  7:57:50 1999
# from tables.sql,v 1.13 1999/08/13 17:06:21 moeller Exp 
package Bivio::Biz::Model::RealmOwner;
use strict;
$Bivio::Biz::Model::RealmOwner::VERSION = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);
$_ = $Bivio::Biz::Model::RealmOwner::VERSION;

=head1 NAME

Bivio::Biz::Model::RealmOwner - interface to realm_owner_t SQL table

=head1 RELEASE SCOPE

bOP

=head1 SYNOPSIS

    use Bivio::Biz::Model::RealmOwner;

=cut

=head1 EXTENDS

L<Bivio::Biz::PropertyModel>

=cut

use Bivio::Biz::PropertyModel;
@Bivio::Biz::Model::RealmOwner::ISA = qw(Bivio::Biz::PropertyModel);

=head1 DESCRIPTION

C<Bivio::Biz::Model::RealmOwner> is the create, read, update,
and delete interface to the C<realm_owner_t> table.

=cut

#=IMPORTS
use Bivio::Agent::TaskId;
use Bivio::Auth::RealmType;
use Bivio::Die;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;
use Bivio::Type::Password;
use Bivio::Type::RealmName;

#=VARIABLES

my($_HOME_TASK_MAP) = {
    map({
        $_ => Bivio::Agent::TaskId->from_name($_->get_name . '_HOME'),
    } (grep($_->equals_by_name(qw(UNKNOWN GENERAL)) ? 0 : 1,
        Bivio::Auth::RealmType->get_list))),
};

=head1 METHODS

=cut

=for html <a name="create"></a>

=head2 create(hash_ref new_values)

Sets I<creation_date_time>, I<password> (to invalid),
and I<display_name> if not set, then calls SUPER.

=cut

sub create {
    my($self, $values) = @_;
    $values->{display_name} = $values->{name}
	    unless defined($values->{display_name});
    $values->{creation_date_time} ||= Bivio::Type::DateTime->now;
    $values->{password} = Bivio::Type::Password->INVALID
	    unless defined($values->{password});
    return $self->SUPER::create($values);
}

=for html <a name="format_email"></a>

=head2 format_email() : string

=head2 static format_email(Bivio::Biz::Model model, string model_prefix) : string

Returns fully-qualified email address for this realm or '' if the
realm is an offline user.

See L<format_name|"format_name"> for params.

=cut

sub format_email {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    my($name) = $proto->format_name($model, $model_prefix);
    return $name ? $model->get_request->format_email($name) : '';
}

=for html <a name="format_http"></a>

=head2 format_http() : string

=head2 static format_http(Bivio::Biz::Model model, string model_prefix) : string

Returns the absolute URL (with http) to access (the root of) this realm.

HACK!

See L<format_name|"format_name"> for params.

=cut

sub format_http {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    return $model->get_request->format_http_prefix
        . $proto->format_uri($model, $model_prefix);
}

=for html <a name="format_mailto"></a>

=head2 format_mailto() : string

=head2 static format_mailto(Bivio::Biz::Model model, string model_prefix) : string

Returns email address with C<mailto:> prefix.

See L<format_name|"format_name"> for params.

=cut

sub format_mailto {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    return $model->get_request->format_mailto($proto->format_email(
        $model, $model_prefix));
}

=for html <a name="format_name"></a>

=head2 format_name() : string

=head2 static format_name(Bivio::Biz::Model model, string model_prefix) : string

Returns the name formatted for display. Accounting offline users
return ''.

In the second form, I<model> is used to get the values, not I<self>.
Other Models can declare a method of the form:

    sub format_name {
	my($self) = shift;
	Bivio::Biz::Model::RealmOwner->format($self, 'RealmOwner.', @_);
    }

=cut

sub format_name {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    return Bivio::Type::RealmName->to_string(
        $model->get($model_prefix . 'name'));
}

=for html <a name="format_uri"></a>

=head2 format_uri() : string

=head2 static format_uri(Bivio::Biz::Model model, string model_prefix) : string

Returns the URI to access the HOME task for this realm.

See L<format_name|"format_name"> for params.

=cut

sub format_uri {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    my($name) = $proto->format_name($model, $model_prefix);
    Bivio::Die->die($model->get($model_prefix . 'name'),
        ': must not be offline user') unless $name;
    my($task) = $_HOME_TASK_MAP->{$model->get($model_prefix . 'realm_type')};
    Bivio::Die->die($model->get($model_prefix . 'name'), ', ',
        $model->get($model_prefix . 'realm_type'),
        ': invalid realm type') unless $task;
    return $model->get_request->format_uri($task, undef, $name, undef);
}

=for html <a name="has_valid_password"></a>

=head2 has_valid_password() : boolean

Returns true if self's password is valid.

=cut

sub has_valid_password {
    my($self) = @_;
    return Bivio::Type::Password->is_valid($self->get('password'));
}

=for html <a name="init_db"></a>

=head2 init_db()

Initializes database with default realms.  The default realms
have special realm_ids.

=cut

sub init_db {
    my($self) = @_;

    foreach my $rt (Bivio::Auth::RealmType->get_list) {
	next if $rt->equals_by_name('UNKNOWN');
	$self->create({
	    name => lc($rt->get_name),
	    realm_id => $rt->as_int,
	    realm_type => $rt,
	});
    }
    return;
}

=for html <a name="internal_initialize"></a>

=head2 internal_initialize() : hash_ref

B<FOR INTERNAL USE ONLY>

=cut

sub internal_initialize {
    return {
	version => 1,
	table_name => 'realm_owner_t',
	columns => {
            realm_id => ['PrimaryId', 'PRIMARY_KEY'],
            name => ['RealmName', 'NOT_NULL_UNIQUE'],
            password => ['Password', 'NOT_NULL'],
            realm_type => ['Bivio::Auth::RealmType', 'NOT_NULL'],
	    display_name => ['Line', 'NOT_NULL'],
	    creation_date_time => ['DateTime', 'NOT_NULL'],
        },
	auth_id => 'realm_id',
# prevent circular dependency, handled by overridden unsafe_get_model()
#	other => [
#	    [qw(realm_id Club.club_id User.user_id)],
#	],
    };
}

=for html <a name="invalidate_password"></a>

=head2 invalidate_password()

Invalidates I<self>'s password.

=cut

sub invalidate_password {
    my($self) = @_;
    $self->update({password => Bivio::Type::Password->INVALID});
    return;
}

=for html <a name="is_auth_realm"></a>

=head2 is_auth_realm() : boolean

=head2 static is_auth_realm(Bivio::Biz::Model model, string model_prefix) : boolean

Returns true if the current row is the request's auth_realm.

=cut

sub is_auth_realm {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    my($auth_id) = $model->get_request->get('auth_id');
    return 0 unless $auth_id;
    return $model->get($model_prefix . 'realm_id') eq $auth_id ? 1 : 0;
}

=for html <a name="is_auth_user"></a>

=head2 is_auth_user() : boolean

=head2 static is_auth_user(Bivio::Biz::Model model, string model_prefix) : boolean

Returns true if the current row is the request's auth_user.

=cut

sub is_auth_user {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    my($auth_user) = $model->get_request->get('auth_user');
    return 0 unless $auth_user;
    return $model->get($model_prefix . 'realm_id')
        eq $auth_user->get('realm_id') ? 1 : 0;
}

=for html <a name="is_default"></a>

=head2 is_default() : boolean

=head2 static is_default(Bivio::Biz::Model model, string model_prefix) : boolean

Returns true if the realm is one of the default realms (general,
user, club).

=cut

sub is_default {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    # Default realms have ids same as their types as_int.
    return $model->get($model_prefix . 'realm_type')->as_int
	eq $model->get($model_prefix . 'realm_id') ? 1 : 0;
}

=for html <a name="is_name_eq_email"></a>

=head2 static is_name_eq_email(Bivio::Agent::Request req, string name, string email) : boolean

If I<name> points to I<email>, returns true.  Caller should
put error C<EMAIL_LOOP> on the email.  If I<name> or I<email>
C<undef>, returns false.

=cut

sub is_name_eq_email {
    my(undef, $req, $name, $email) = @_;
    return 0 unless defined($name) && defined($email);
    my($mail_host) = Bivio::UI::Facade->get_value('mail_host', $req);
#TODO: ANY OTHER mail_host aliases?
    return $email eq $name . '@' . $mail_host
        || $email eq $name . '@www.' . $mail_host;
}

=for html <a name="is_offline_user"></a>

=head2 is_offline_user() : boolean

=head2 static is_offline_user(Bivio::Biz::Model model, string model_prefix) : boolean

Returns true if is a offline realm.

See L<format_name|"format_name"> for params.

=cut

sub is_offline_user {
    my($proto, $model, $model_prefix) = shift->internal_get_target(@_);
    return Bivio::Type::RealmName->is_offline(
        $model->get($model_prefix . 'name'));
}

=for html <a name="unauth_load_by_email"></a>

=head2 unauth_load_by_email(string email) : boolean

=head2 unauth_load_by_email(string email, hash query) : boolean

Tries to load this realm using I<email> and any other I<query> parameters,
e.g. (realm_type, Bivio::Auth::RealmType->USER()).

I<email> is interpreted as follows:

=over 4

=item *

An C<Bivio::Biz::Model::Email> is loaded with I<email>.  If found,
loads the I<realm_id> of the model.

=item *

Parsed for the I<mail_host> associated with this request.
If it matches, the mailhost is stripped and the (syntactically
valid realm) name is used to find a realm owner.

=item *

Returns false.

=back

=cut

sub unauth_load_by_email {
    my($self, $email, @query) = @_;
    # Emails are always lower case
    $email = lc($email);
    # Load the email.  Return the result of the next unauth_load, just in case
    my($em) = $self->new_other('Email');
    return $self->unauth_load({@query, realm_id => $em->get('realm_id')})
        if $em->unauth_load({email => $email});
    return unless Bivio::IO::ClassLoader->simple_require(
        'Bivio::UI::Facade')->is_fully_initialized;
    # Strip off @mail_host and validate resulting name
    my($mail_host) = '@' . Bivio::UI::Facade->get_value('mail_host',
        $self->get_request);
    return 0 unless $email =~ s/\Q$mail_host\E$//i;
    my($name) = Bivio::Type::RealmName->from_literal($email);
    return 0 unless defined($name);
    # Is it a valid user/club?
    return $self->unauth_load({@query, name => $name});
}

=for html <a name="unauth_load_by_email_id_or_name"></a>

=head2 unauth_load_by_email_id_or_name(string email_id_or_name) : boolean

If email_id_or_name has an '@', will try to unauth_load_by_email.
Otherwise, tries to load by id or name.

=cut

sub unauth_load_by_email_id_or_name {
    my($self, $email_id_or_name) = @_;
    return $self->unauth_load_by_email($email_id_or_name)
        if $email_id_or_name =~ /@/;
    return $self->unauth_load({realm_id => $email_id_or_name})
        if $email_id_or_name =~ /^\d+$/;
    return $self->unauth_load({name => lc($email_id_or_name)});
}

=for html <a name="unauth_load_by_id_or_name_or_die"></a>

=head2 unauth_load_by_id_or_name_or_die(string id_or_name) : Bivio::Biz::Model::RealmOwner

=head2 unauth_load_by_id_or_name_or_die(string id_or_name, any realm_type) : Bivio::Biz::Model::RealmOwner

Loads I<id_or_name> or dies with NOT_FOUND.  If I<realm_type> is specified, further qualifies the query.

=cut

sub unauth_load_by_id_or_name_or_die {
    my($self, $id_or_name, $realm_type) = @_;
    return $self->unauth_load_or_die({
        ($id_or_name =~ /^\d+$/ ? 'realm_id' : 'name') => lc($id_or_name),
        $realm_type
	    ? (realm_type => Bivio::Auth::RealmType->from_any($realm_type))
	    : (),
    });
}

=for html <a name="unsafe_get_model"></a>

=head2 unsafe_get_model(string name) : Bivio::Biz::PropertyModel

Overridden to support getting the related User or Club.
For backward compatibility.

=cut

sub unsafe_get_model {
    my($self, $name) = @_;

    if ($name eq 'User' || $name eq 'Club') {
	my($model) =  $self->new_other($name);
	return $model->unauth_load(lc($name).'_id' => $self->get('realm_id'))
            ? $model : undef;
    }
    return $self->SUPER::unsafe_get_model($name);
}

#=PRIVATE METHODS

=head1 COPYRIGHT

Copyright (c) 1999-2001 bivio Inc.  All rights reserved.

=head1 VERSION

$Id$

=cut

1;
