# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
# Generated by ../generate.PL on Wed Aug 18  7:57:50 1999
# from tables.sql,v 1.13 1999/08/13 17:06:21 moeller Exp 
package Bivio::Biz::Model::RealmOwner;
use strict;
$Bivio::Biz::Model::RealmOwner::VERSION = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);
$_ = $Bivio::Biz::Model::RealmOwner::VERSION;

=head1 NAME

Bivio::Biz::Model::RealmOwner - interface to realm_owner_t SQL table

=head1 SYNOPSIS

    use Bivio::Biz::Model::RealmOwner;
    Bivio::Biz::Model::RealmOwner->new($req);

=cut

=head1 EXTENDS

L<Bivio::Biz::PropertyModel>

=cut

use Bivio::Biz::PropertyModel;
@Bivio::Biz::Model::RealmOwner::ISA = qw(Bivio::Biz::PropertyModel);

=head1 DESCRIPTION

C<Bivio::Biz::Model::RealmOwner> is the create, read, update,
and delete interface to the C<realm_owner_t> table.

=cut

#=IMPORTS
# also uses Club, Email, User models
use Bivio::Agent::TaskId;
use Bivio::Auth::RealmType;
use Bivio::Die;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;
use Bivio::Type::Password;
use Bivio::Type::RealmName;

#=VARIABLES
my($_PACKAGE) = __PACKAGE__;
my($_DEMO_SUFFIX) = Bivio::Type::RealmName::DEMO_CLUB_SUFFIX();
my($_OFFLINE_PREFIX) = Bivio::Type::RealmName::OFFLINE_PREFIX();

#TODO: this needs to be configurable, maybe a method on RealmType?
my(%_HOME_TASK_MAP) = (
    Bivio::Auth::RealmType::CLUB() => Bivio::Agent::TaskId::CLUB_HOME(),
    Bivio::Auth::RealmType::USER() => Bivio::Agent::TaskId::USER_HOME(),
);
my($_MAIL_HOST);

=head1 METHODS

=cut

=for html <a name="create"></a>

=head2 create(hash_ref new_values)

Sets I<creation_date_time>, I<password> (to invalid),
and I<display_name> if not set, then calls SUPER.

=cut

sub create {
    my($self, $values) = @_;
    $values->{display_name} = $values->{name}
	    unless defined($values->{display_name});
    $values->{creation_date_time} = Bivio::Type::DateTime->now()
	    unless defined($values->{creation_date_time});
    $values->{password} = Bivio::Type::Password->INVALID()
	    unless defined($values->{password});
    return $self->SUPER::create($values);
}

=for html <a name="format_demo_club_name"></a>

=head2 format_demo_club_name() : string

Formats demo club name for this user.

=cut

sub format_demo_club_name {
    my($self) = @_;
    my($demo_threshold) = Bivio::Type::RealmName->get_width
	    - length($_DEMO_SUFFIX);
    my($name) = $self->get('name');

    # This is a legitimate realm name, but users can't enter it because
    # it begins with a number and ends with the demo suffix.
    # See Type::RealmName
    $name = $self->get('realm_id') if length($name) > $demo_threshold;
    return $name.Bivio::Type::RealmName::DEMO_CLUB_SUFFIX();
}

=for html <a name="format_email"></a>

=head2 format_email() : string

=head2 static format_email(Bivio::Biz::Model model, string model_prefix) : string

Returns fully-qualified email address for this realm or '' if the
realm is an accounting offline user.

See L<format_name|"format_name"> for params.

=cut

sub format_email {
    my($proto, $model, $model_prefix) = _process_model_prefix_args(@_);
    my($name) = $proto->format_name($model, $model_prefix);
    return $name ? $model->get_request->format_email($name) : '';
}

=for html <a name="format_http"></a>

=head2 format_http() : string

=head2 static format_http(Bivio::Biz::Model model, string model_prefix) : string

Returns the absolute URL (with http) to access (the root of) this realm.

HACK!

See L<format_name|"format_name"> for params.

=cut

sub format_http {
    my($proto, $model, $model_prefix) = _process_model_prefix_args(@_);
    return $model->get_request->format_http_prefix.$proto->format_uri(
	   $model, $model_prefix);
}

=for html <a name="format_mailto"></a>

=head2 format_mailto() : string

=head2 static format_mailto(Bivio::Biz::Model model, string model_prefix) : string

Returns email address with C<mailto:> prefix.

See L<format_name|"format_name"> for params.

=cut

sub format_mailto {
    my($proto, $model, $model_prefix) = _process_model_prefix_args(@_);
    return $model->get_request->format_mailto($proto->format_email(
	   $model, $model_prefix));
}

=for html <a name="format_name"></a>

=head2 format_name() : string

=head2 static format_name(Bivio::Biz::Model model, string model_prefix) : string

Returns the name formatted for display. Accounting offline users
return ''.

In the second form, I<model> is used to get the values, not I<self>.
Other Models can declare a method of the form:

    sub format_name {
	my($self) = shift;
	Bivio::Biz::Model::Address->format($self, 'RealmOwner.', @_);
    }

=cut

sub format_name {
    my($proto, $model, $model_prefix) = _process_model_prefix_args(@_);
    my($name) = $model->get($model_prefix.'name');

    if ($name =~ /^$_OFFLINE_PREFIX/o) {
	if ($name =~ /^=\(/o) {
	    # show a withdrawn offline name in ()
	    $name =~ s/^=(\(\w+\))\d+/$1/;
	}
	else {
	    $name = '';
	}
    }
    return $name;
}

=for html <a name="format_uri"></a>

=head2 format_uri() : string

=head2 static format_uri(Bivio::Biz::Model model, string model_prefix) : string

Returns the URI to access the HOME task for this realm.

See L<format_name|"format_name"> for params.

=cut

sub format_uri {
    my($proto, $model, $model_prefix) = _process_model_prefix_args(@_);
    my($name) = $proto->format_name($model, $model_prefix);
    Bivio::Die->die($model->get($model_prefix.'name'),
	    ': must not be offline user') unless $name;
    my($task) = $_HOME_TASK_MAP{$model->get($model_prefix.'realm_type')};
    Bivio::Die->die($model->get($model_prefix.'name'), ', ',
	    $model->get($model_prefix.'realm_type'),
	    ': invalid realm type') unless $task;
    return $model->get_request->format_uri($task, undef, $name, undef);
}

=for html <a name="has_valid_password"></a>

=head2 has_valid_password() : boolean

Returns true if self's password is valid.

=cut

sub has_valid_password {
    my($self) = @_;
    return Bivio::Type::Password->is_valid($self->get('password'));
}

=for html <a name="internal_initialize"></a>

=head2 internal_initialize() : hash_ref

B<FOR INTERNAL USE ONLY>

=cut

sub internal_initialize {
    return {
	version => 1,
	table_name => 'realm_owner_t',
	columns => {
            realm_id => ['PrimaryId', 'PRIMARY_KEY'],
            name => ['RealmName', 'NOT_NULL_UNIQUE'],
            password => ['Password', 'NOT_NULL'],
            realm_type => ['Bivio::Auth::RealmType', 'NOT_NULL'],
	    display_name => ['Line', 'NOT_NULL'],
	    creation_date_time => ['DateTime', 'NOT_NULL'],
        },
	auth_id => 'realm_id',
# prevent circular dependency, handled by overridden unsafe_get_model()
#	other => [
#	    [qw(realm_id Club.club_id User.user_id)],
#	],
    };
}

=for html <a name="invalidate_password"></a>

=head2 invalidate_password()

Invalidates I<self>'s password.

=cut

sub invalidate_password {
    my($self) = @_;
    $self->update({password => Bivio::Type::Password->INVALID});
    return;
}

=for html <a name="is_auth_user"></a>

=head2 is_auth_user() : boolean

=head2 static is_auth_user(Bivio::Biz::Model model, string model_prefix) : boolean

Returns true if the current row is the request's auth_user.

=cut

sub is_auth_user {
    my($proto, $model, $model_prefix) = _process_model_prefix_args(@_);
    my($auth_user) = $model->get_request->get('auth_user');
    return 0 unless $auth_user;
    return $model->get($model_prefix.'realm_id')
	    eq $auth_user->get('realm_id') ? 1 : 0;
}

=for html <a name="is_default"></a>

=head2 is_default() : boolean

Returns true if the realm is one of the default realms (general,
user, club).

=cut

sub is_default {
    my($self) = @_;
    # Default realms have ids same as their types as_int.
    return $self->get('realm_type')->as_int eq $self->get('realm_id') ? 1 : 0;
}

=for html <a name="is_demo_club"></a>

=head2 is_demo_club() : boolean

=head2 static is_demo_club(string name) : boolean

=head2 static is_demo_club(Bivio::Biz::Model model, string model_prefix) : boolean

Returns true if demo_club.  Gets I<name> from I<self> if not provided.

=cut

sub is_demo_club {
    my($self, $model, $model_prefix) = @_;
    my($name) = defined($model_prefix)
            ? $model->get($model_prefix.'name')
                    : defined($model)
                            ? $model : $self->get('name');
    return $name =~ /$_DEMO_SUFFIX$/o ? 1 : 0;
}

=for html <a name="is_name_eq_email"></a>

=head2 static is_name_eq_email(Bivio::Agent::Request req, string name, string email) : boolean

If I<name> points to I<email>, returns true.  Caller should
put error C<EMAIL_LOOP> on the email.  If I<name> or I<email>
C<undef>, returns false.

=cut

sub is_name_eq_email {
    my(undef, $req, $name, $email) = @_;
    return 0 unless defined($name) && defined($email);
    $_MAIL_HOST = $req->get('mail_host') unless $_MAIL_HOST;
#TODO: ANY OTHER mail_host aliases?
    return $email eq $name.'@'.$_MAIL_HOST
	    || $email eq $name.'@www.'.$_MAIL_HOST;
}

=for html <a name="is_offline_user"></a>

=head2 is_offline_user() : boolean

=head2 static is_offline_user(Bivio::Biz::Model model, string model_prefix) : boolean

Returns true if is a offline realm.

See L<format_name|"format_name"> for params.

=cut

sub is_offline_user {
    my($proto, $model, $model_prefix) = _process_model_prefix_args(@_);
    return $model->get($model_prefix.'name') =~ /^$_OFFLINE_PREFIX/o ? 1 : 0;
}

=for html <a name="unauth_load_by_email"></a>

=head2 unauth_load_by_email(string email) : boolean

=head2 unauth_load_by_email(string email, hash query) : boolean

Tries to load this realm using I<email> and any other I<query> parameters,
e.g. (realm_type, Bivio::Auth::RealmType::USER()).

I<email> is interpreted as follows:

=over 4

=item *

An C<Bivio::Biz::Model::Email> is loaded with I<email>.  If found,
loads the I<realm_id> of the model.

=item *

Parsed for the I<mail_host> associated with this request.
If it matches, the mailhost is stripped and the (syntactically
valid realm) name is used to find a realm owner.

=item *

Returns false.

=back

=cut

sub unauth_load_by_email {
    my($self, $email, @query) = @_;
    my($req) = $self->get_request;
    # Emails are always lower case
    $email = lc($email);

    # Load the email.  Return the result of the next unauth_load, just in case
    my($em) = Bivio::Biz::Model->new($req, 'Email');
    return $self->unauth_load(@query, realm_id => $em->get('realm_id'))
	    if $em->unauth_load(email => $email);

    # Strip off @mail_host and validate resulting name
    my($mail_host) = '@'.$req->get('mail_host');
    return 0 unless $email =~ s/\Q$mail_host\E$//i;
    my($name) = Bivio::Type::RealmName->from_literal($email);
    return 0 unless defined($name);

    # Is it a valid user/club?
    return $self->unauth_load(@query, name => $name);
}

=for html <a name="unauth_load_by_email_id_or_name"></a>

=head2 unauth_load_by_email_id_or_name(string email_id_or_name) : boolean

If email_id_or_name has an '@', will try to unauth_load_by_email.
Otherwise, tries to load by id or name.

=cut

sub unauth_load_by_email_id_or_name {
    my($self, $email_id_or_name) = @_;
    return $self->unauth_load_by_email($email_id_or_name)
	    if $email_id_or_name =~ /@/;
    return $self->unauth_load(realm_id => $email_id_or_name)
	    if $email_id_or_name =~ /^\d+$/;
    return $self->unauth_load(name => lc($email_id_or_name));
}

=for html <a name="unauth_load_by_id_or_name_or_die"></a>

=head2 unauth_load_by_id_or_name_or_die(string id_or_name) : Bivio::Biz::Model::RealmOwner

=head2 unauth_load_by_id_or_name_or_die(string id_or_name, any realm_type) : Bivio::Biz::Model::RealmOwner

Loads I<id_or_name> or dies with NOT_FOUND.  If I<realm_type> is specified, further qualifies the query.

=cut

sub unauth_load_by_id_or_name_or_die {
    my($self, $id_or_name, $realm_type) = @_;
    return $self->unauth_load_or_die(
	    ($id_or_name =~ /^\d+$/ ? 'realm_id' : 'name') => lc($id_or_name),
	    $realm_type
	    ? (realm_type => Bivio::Auth::RealmType->from_any($realm_type))
	    : ());
}

=for html <a name="unsafe_get_model"></a>

=head2 unsafe_get_model(string name) : Bivio::Biz::PropertyModel

Overridden to support getting the related User or Club.
For backward compatibility.

=cut

sub unsafe_get_model {
    my($self, $name) = @_;
    if ($name eq 'User' || $name eq 'Club') {
	my($model) =  Bivio::Biz::Model->new($self->get_request, $name);
	return $model->unauth_load(lc($name).'_id' => $self->get('realm_id'))
		? $model : undef;
    }
    return $self->SUPER::unsafe_get_model($name);
}

#=PRIVATE METHODS

# _process_model_prefix_args(self) : (proto, Bivio::Biz::Model, string)
#
# _process_model_prefix_args(proto, Bivio::Biz::Model model, string model_prefix) : (proto, Bivio::Biz::Model, string)
#
# Returns the class, target model and optional model prefix.
#
sub _process_model_prefix_args {
    my($self, $model, $model_prefix) = @_;
    return (ref($self) || $self, $model || $self, $model_prefix || '');
}

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

1;
