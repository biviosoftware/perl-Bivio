# Copyright (c) 2002 bivio Software, Inc.  All Rights Reserved.
# $Id$
package Bivio::Test::HTMLParser::Tables;
use strict;
$Bivio::Test::HTMLParser::Tables::VERSION = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);
$_ = $Bivio::Test::HTMLParser::Tables::VERSION;

=head1 NAME

Bivio::Test::HTMLParser::Tables - models tables with headings (TH elements) on the page

=head1 RELEASE SCOPE

bOP

=head1 SYNOPSIS

    use Bivio::Test::HTMLParser::Tables;

=cut

=head1 EXTENDS

L<Bivio::Test::HTMLParser>

=cut

use Bivio::Test::HTMLParser;
@Bivio::Test::HTMLParser::Tables::ISA = ('Bivio::Test::HTMLParser');

=head1 DESCRIPTION

C<Bivio::Test::HTMLParser::Tables> models tables with headings on the page.
These tables are typically generated by
L<Bivio::UI::HTML::Widget::Table|Bivio::UI::HTML::Widget::Table>,
but can be any table with TH for headings.

=cut

#=IMPORTS
use Bivio::IO::Trace;
use Bivio::Test::HTMLParser::Tables::Cell;

#=VARIABLES
my($_IDI) = __PACKAGE__->instance_data_index;
__PACKAGE__->register(['Cleaner']);

=head1 FACTORIES

=cut

=for html <a name="new"></a>

=head2 static new(Bivio::Test::HTMLParser parser) : Bivio::Test::HTMLParser::Tables

Parses cleaned html for forms.

=cut

sub new {
    my($proto, $parser) = @_;
    my($self) = $proto->SUPER::new;
    $self->[$_IDI] = {};
    return $self;
}

=head1 METHODS

=cut

=for html <a name="do_rows"></a>

=head2 do_rows(string table_name, code_ref do_rows_callback)

Iterates over the rows over I<table_name>, calling
L<do_rows_callback|"do_rows_callback"> for each row.

The special field C<_row_index> is set to the value of the index of that row.

=cut

sub do_rows {
    my($self, $table_name, $do_rows_callback) = @_;
    my($index) = -1;

    my($t) = _assert_table($self, $table_name);
    foreach my $row (@{$t->{rows}}) {
	my($i) = -1;
	$index++;
        last unless $do_rows_callback->(
	    {
		_row_index => $index,
		map({
                    my($value) = $row->[++$i];
                    defined($value)
                        ? ($_->get('text') => $value)
                        : ();
                } @{$t->{headings}}),
	    },
	    $index,
	);
    }
    return;
}

=for html <a name="do_rows_callback"></a>

=head2 callback do_rows_callback(hash_ref row, int index) : boolean

Called by L<do_rows|"do_rows"> for each I<row>, which is a map of
column to cell value.  I<row> may be used destructively by.
I<index> is the row number, starting at 0.

Returns true to continue iterating, or false if the iteration should exit.

=cut

$_ = <<'}'; # emacs
sub do_rows_callback {
}

=for html <a name="find_row"></a>

=head2 find_row(string column_name, string column_value) : hash_ref

=head2 find_row(string table_name, string column_name, string column_value) : hash_ref

Return the hash_ref of the the row where the value in I<column_name>
matches I<column_value>.  Dies if row not found.

If I<table_name> not supplied, calls L<get_by_headings|"get_by_headings"> with
I<column_name> for table.

=cut

sub find_row {
    my($self) = shift;
    my($table_name) = @_ > 2 ? shift
	: $self->get_by_headings($_[0])->{headings}->[0]->get('text');
    my($column_name, $column_value) = @_;
    my($found_row);
    _assert_column($self, $table_name, $column_name);
    my($misses) = [];
    $self->do_rows($table_name,
	sub {
	    my($row) = @_;
            # not all rows have all columns defined
            return 1 unless exists($row->{$column_name});
	    my($t) = $row->{$column_name}->get('text');
	    push(@$misses, $t);
	    $found_row = $row
		if ref($column_value) eq 'Regexp' ? $t =~ $column_value
		    : $t eq $column_value;
	    return $found_row ? 0 : 1;
	});
    return $found_row || Bivio::Die->die(
	$column_value, ': not found in column "', $column_name,
	'" values: ', $misses,
    );
}

=for html <a name="get_by_headings"></a>

=head2 get_by_headings(string name, ...) : hash_ref

Returns the table data by finding by I<name>(s) in heading fields.

=cut

sub get_by_headings {
    my($self, @name) = @_;
    my($found);
    my($tables) = $self->get_shallow_copy;
 TABLE: while (my($table, $values) = each(%$tables)) {
	foreach my $n (@name) {
	    next TABLE
		unless grep($n eq $_->get('text'), @{$values->{headings}});
	}
	Bivio::Die->die(\@name, ': too many tables matched headings')
	    if $found;
	$found = $values;
    }
    return $found || Bivio::Die->die(\@name, ': no table matches named headings');
}

=for html <a name="html_parser_end"></a>

=head2 html_parser_end(string tag, string origtext)

Dispatch to the _end_XXX routines.

=cut

sub html_parser_end {
    my($self, $tag) = (shift, @_);
    my($fields) = $self->[$_IDI];
    $fields->{links}->html_parser_end(@_)
	if $fields->{links};
    _call_op('end', $tag, $self);
    return;
}

=for html <a name="html_parser_start"></a>

=head2 html_parser_start(string tag, hash_ref attr, array_ref attrseq, string origtext)

Calls _fixup_attr then dispatches to the _start_XXX routines.

=cut

sub html_parser_start {
    my($self, $tag, $attr) = (shift, @_);
    my($fields) = $self->[$_IDI];
    $fields->{links}->html_parser_start(@_)
	if $fields->{links};
    return if _call_op('start', $tag, $self, $attr);
    return _start_input($self, $attr)
	if $attr->{type};
    return;
}

=for html <a name="html_parser_text"></a>

=head2 html_parser_text(string text)

Parses the tables.  Called internally.

=cut

sub html_parser_text {
    my($self, $text) = (shift, @_);
    my($fields) = $self->[$_IDI];
    $fields->{links}->html_parser_text(@_)
	if $fields->{links};
    return unless $fields->{in_data_table};
    $fields->{text} .= $text;
    return;
}

#=PRIVATE METHODS

# _assert_column(self, string table_name, string column_name)
sub _assert_column {
    my($self, $table_name, $column_name) = @_;
    my($table) = _assert_table($self, $table_name);
    Bivio::Die->die('column name not found: ', $column_name)
        unless grep($column_name eq $_->get('text'), @{$table->{headings}});
    return;
}

# _assert_table(self, string table) : hash_ref
sub _assert_table {
    my($self, $table_name) = @_;
    Bivio::Die->die('table name: "', $table_name,
        '" not found in ', $self->get_keys)
        unless $self->unsafe_get($table_name);
    return $self->get($table_name);
}

# _call_op(string prefix, string tag, any arg, ...) : boolean
#
# Calls _$prefix_$tag if it is defined.
#
sub _call_op {
    my($prefix, $tag, @arg) = @_;
    my($op) = \&{"_$prefix" . "_$tag"};
    return 0
	unless defined(&$op);
    $op->(@arg);
    return 1;
}

# _delete_empty_rows(array_ref rows)
#
# Deletes totally empty rows from the table.  They are probably separator
# rows.
#
sub _delete_empty_rows {
    my($rows) = @_;
    for (my($i) = 0; $i < @$rows; $i++) {
	next if grep(defined($_) && length($_->get('text')), @{$rows->[$i]});
	_trace($rows->[$i]) if $_TRACE;
	splice(@$rows, $i--, 1)
    }
    return;
}

# _end_table(self)
#
# The only tables we track are "data" tables.
#
sub _end_table {
    my($self) = @_;
    my($fields) = $self->[$_IDI];
    return unless $fields->{in_data_table} && !--$fields->{in_data_table};
    # Delete totally empty rows (probably separators)
    _delete_empty_rows($fields->{table}->{rows});

    my($elements) = $self->get('elements');
    my($name) = $fields->{table}->{label} ||= '_anon#'
        . keys(%{$self->get('elements')});

    if ($elements->{$name}) {
        my($count) = 1;

        while ($elements->{$name . '#' . $count}) {
            $count++;
        }
        $name .= '#' . $count;
    }
    $elements->{$name} = $fields->{table};
    _trace($fields->{table}) if $_TRACE;
    delete($fields->{table});
    return;
}

# _end_td(self)
#
# Adds the text from column to current row
#
sub _end_td {
    my($self) = @_;
    my($fields) = $self->[$_IDI];
    return unless $fields->{table};
    _save_cell($self, $fields,
	$fields->{table}->{rows}->[$#{$fields->{table}->{rows}}]);
    return;
}

# _end_th(self)
#
# Ends the "th".  Saves the cell and id for table (if not already there).
#
sub _end_th {
    my($self) = @_;
    my($fields) = $self->[$_IDI];
    return unless $fields->{table};
    my($t) = _save_cell($self, $fields, $fields->{table}->{headings});
    $fields->{table}->{label} ||= $t;
    return;
}

# _found_table(hash_ref fields, string id)
#
# Either at <table id=xxx> or at every <th>.  Returns true if
# initializes table.
#
sub _found_table {
    my($fields, $id) = @_;
    unless ($fields->{in_data_table}) {
	$fields->{in_data_table}++;
	$fields->{table} = {
	    headings => [],
	    rows => [],
	    label => $id,
	};
    }
    elsif ($fields->{in_data_table} > 1) {
	die('nested data tables not supported');
    }
    return;
}

# _in_data(hash_ref fields) : boolean
#
# Returns true if at data table level.
#
sub _in_data {
    my($fields) = @_;
    return ($fields->{in_data_table} || 0) == 1 ? 1 : 0;
}

sub _links {
    my($self) = @_;
    my($fields) = $self->[$_IDI];
    return $fields->{links} ||= Bivio::Test::HTMLParser::Links->new->internal_put({
	cleaner => $self->get('cleaner'),
	elements => {},
    });
}

# _save_cell(self, hash_ref fields, array_ref row) : string
#
# Checks colspan to see if needs filling.  Returns the found text,
# if any.
#
sub _save_cell {
    my($self, $fields, $row) = @_;
    return
	unless $fields->{in_data_table} == 1;
    my($t) = $self->get('cleaner')->text(_text($fields));
    push(@$row, Bivio::Test::HTMLParser::Tables::Cell->new({
	text => $t,
	Links => _links($self)->internal_put(
	    _links($self)->get('elements'))->set_read_only,
    }));
    $fields->{links} = undef;
    _trace($t) if $_TRACE;
    push(@$row, undef)
	while --$fields->{colspan} > 0;
    return $t;
}

# _start_input(self, hash_ref attr)
#
# Saves "value" attribute.
#
sub _start_input {
    my($self, $attr) = @_;
    my($fields) = $self->[$_IDI];
    $fields->{text} .= $attr->{value} || '';
    return;
}

# _start_table(self, hash_ref attr)
#
# Increments in_data_table
#
sub _start_table {
    my($self, $attr) = @_;
    my($fields) = $self->[$_IDI];
    $fields->{in_data_table}++
	if $fields->{in_data_table};
    _found_table($fields, $attr->{id})
	if $attr->{id};
    return;
}

# _start_td(self, hash_ref attr)
#
# Starts a TD.
#
sub _start_td {
    my($self, $attr) = @_;
    my($fields) = $self->[$_IDI];
    # Don't separate cells in nested table
#TODO: Format like a table, e.g. </td> -> ' ', </tr> -> \n
    return unless _in_data($fields);
    $fields->{text} = '';
    $fields->{colspan} = $attr->{colspan} || 1;
    _links($self);
    return;
}

# _start_th(self, hash_ref attr)
#
# Starts a TH and initializes {table} if necessary.
#
sub _start_th {
    my($self, $attrs) = @_;
    my($fields) = $self->[$_IDI];
    _found_table($fields);
    return _start_td(@_);
}

# _start_tr(self, hash_ref attr, string tag)
#
# Only adds rows if rows has been initialized.
#
sub _start_tr {
    my($self, $attr) = @_;
    my($fields) = $self->[$_IDI];
    return unless _in_data($fields);
    push(@{$fields->{table}->{rows}}, [])
	if $fields->{table}->{rows};
    return;
}

# _text(hash_ref fields) : string
#
# Returns the cleaned text field or an empty string if not defined.
#
sub _text {
    my($fields) = @_;
    my($res) = defined($fields->{text}) ? $fields->{text} : '';
    $fields->{text} = undef;
    return $res;
}

=head1 COPYRIGHT

Copyright (c) 2002 bivio Software, Inc.  All Rights Reserved.

=head1 VERSION

$Id$

=cut

1;
