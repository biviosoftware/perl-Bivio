# Copyright (c) 2002 bivio Software Artisans, Inc.  All Rights Reserved.
# $Id$
package Bivio::Test::HTMLParser::Tables;
use strict;
$Bivio::Test::HTMLParser::Tables::VERSION = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);
$_ = $Bivio::Test::HTMLParser::Tables::VERSION;

=head1 NAME

Bivio::Test::HTMLParser::Tables - models tables with headings (TH elements) on the page

=head1 RELEASE SCOPE

bOP

=head1 SYNOPSIS

    use Bivio::Test::HTMLParser::Tables;

=cut

=head1 EXTENDS

L<Bivio::Test::HTMLParser>

=cut

use Bivio::Test::HTMLParser;
@Bivio::Test::HTMLParser::Tables::ISA = ('Bivio::Test::HTMLParser');

=head1 DESCRIPTION

C<Bivio::Test::HTMLParser::Tables> models tables with headings on the page.
These tables are typically generated by
L<Bivio::UI::HTML::Widget::Table|Bivio::UI::HTML::Widget::Table>,
but can be any table with TH for headings.

=cut

#=IMPORTS
use Bivio::IO::Trace;

#=VARIABLES
use vars ('$_TRACE');
Bivio::IO::Trace->register;
my($_IDI) = __PACKAGE__->instance_data_index;
__PACKAGE__->register(['Cleaner']);

=head1 FACTORIES

=cut

=for html <a name="new"></a>

=head2 static new(Bivio::Test::HTMLParser parser) : Bivio::Test::HTMLParser::Tables

Parses cleaned html for forms.

=cut

sub new {
    my($proto, $parser) = @_;
    my($self) = $proto->SUPER::new;
    my($fields) = $self->[$_IDI] = {
	cleaner => $parser->get('Cleaner'),
	tables => {},
    };

    my($p) = Bivio::Ext::HTMLParser->new($self);
    $p->ignore_elements(qw(script style));
    $p->parse($fields->{cleaner}->get('html'));

    $self->internal_put($fields->{tables});
    # We only need the fields while parsing.  Avoids memory leaks (circ refs)
    $self->[$_IDI] = undef;
    return $self->set_read_only;
}

=head1 METHODS

=cut

=for html <a name="get_by_headings"></a>

=head2 get_by_headings(string name, ...) : hash_ref

Returns the table data by finding by I<name>(s) in heading fields.

=cut

sub get_by_headings {
    my($self, @name) = @_;
    my($found);
    my($tables) = $self->get_shallow_copy;
 TABLE: while (my($table, $values) = each(%$tables)) {
	foreach my $n (@name) {
	    next TABLE
		unless grep($n eq $_, @{$values->{headings}});
	}
	Bivio::Die->die(\@name, ': too many tables matched headings')
	    if $found;
	$found = $values;
    }
    return $found || Bivio::Die->die(\@name, ': no table matches named headings');
}

=for html <a name="html_parser_end"></a>

=head2 html_parser_end(string tag, string origtext)

Dispatch to the _end_XXX routines.

=cut

sub html_parser_end {
    my($self, $tag) = @_;
    my($fields) = $self->[$_IDI];
    _call_op('end', $tag, $fields);
    return;
}

=for html <a name="html_parser_start"></a>

=head2 html_parser_start(string tag, hash_ref attr, array_ref attrseq, string origtext)

Calls _fixup_attr then dispatches to the _start_XXX routines.

=cut

sub html_parser_start {
    my($self, $tag, $attr) = @_;
    my($fields) = $self->[$_IDI];
    return if _call_op('start', $tag, $fields, $attr);
    return _start_input($fields, $attr)
	if $attr->{type};
    return;
}

=for html <a name="html_parser_text"></a>

=head2 html_parser_text(string text)

Parses the tables.  Called internally.

=cut

sub html_parser_text {
    my($self, $text) = @_;
    my($fields) = $self->[$_IDI];
    return unless $fields->{in_data_table};
    $fields->{text} .= $fields->{cleaner}->text($text);
    return;
}

#=PRIVATE METHODS

# _call_op(string prefix, string tag, any arg, ...) : boolean
#
# Calls _$prefix_$tag if it is defined.
#
sub _call_op {
    my($prefix, $tag, @arg) = @_;
    my($op) = \&{"_$prefix" . "_$tag"};
    return 0
	unless defined(&$op);
    $op->(@arg);
    return 1;
}

# _delete_empty_rows(array_ref rows)
#
# Deletes totally empty rows from the table.  They are probably separator
# rows.
#
sub _delete_empty_rows {
    my($rows) = @_;
    for (my($i) = 0; $i < @$rows; $i++) {
	next if grep(defined($_) && length($_), @{$rows->[$i]});
	_trace($rows->[$i]) if $_TRACE;
	splice(@$rows, $i--, 1)
    }
    return;
}

# _end_table(hash_ref fields)
#
# The only tables we track are "data" tables.
#
sub _end_table {
    my($fields) = @_;
    return unless $fields->{in_data_table} && !--$fields->{in_data_table};
    # Delete totally empty rows (probably separators)
    _delete_empty_rows($fields->{table}->{rows});
    $fields->{tables}->{
	$fields->{table}->{label} ||= '_anon#' . keys(%{$fields->{tables}})
    } = $fields->{table};
    _trace($fields->{table}) if $_TRACE;
    delete($fields->{table});
    return;
}

# _end_td(hash_ref fields)
#
# Adds the text from column to current row
#
sub _end_td {
    my($fields) = @_;
    return unless $fields->{table};
    _save_cell($fields,
	$fields->{table}->{rows}->[$#{$fields->{table}->{rows}}]);
    return;
}

# _end_th(hash_ref fields)
#
# Ends the "th".  Saves the cell and id for table (if not already there).
#
sub _end_th {
    my($fields) = @_;
    return unless $fields->{table};
    my($t) = _save_cell($fields, $fields->{table}->{headings});
    $fields->{table}->{label} ||= $t;
    return;
}

# _found_table(hash_ref fields, string id)
#
# Either at <table id=xxx> or at every <th>.  Returns true if
# initializes table.
#
sub _found_table {
    my($fields, $id) = @_;
    unless ($fields->{in_data_table}) {
	$fields->{in_data_table}++;
	$fields->{table} = {
	    headings => [],
	    rows => [],
	    label => $id,
	};
    }
    elsif ($fields->{in_data_table} > 1) {
	die('nested data tables not supported');
    }
    return;
}

# _in_data(hash_ref fields) : boolean
#
# Returns true if at data table level.
#
sub _in_data {
    my($fields) = @_;
    return ($fields->{in_data_table} || 0) == 1 ? 1 : 0;
}

# _save_cell(hash_ref fields, array_ref row) : string
#
# Checks colspan to see if needs filling.  Returns the found text,
# if any.
#
sub _save_cell {
    my($fields, $row) = @_;
    return
	unless $fields->{in_data_table} == 1;
    my($t) = _text($fields);
    push(@$row, $t);
    _trace($t) if $_TRACE;
    push(@$row, undef)
	while --$fields->{colspan} > 0;
    return $t;
}

# _start_input(hash_ref fields, hash_ref attr)
#
# Saves "value" attribute.
#
sub _start_input {
    my($fields, $attr) = @_;
    $fields->{text} .= $attr->{value} || '';
    return;
}

# _start_table(hash_ref fields, hash_ref attr)
#
# Increments in_data_table
#
sub _start_table {
    my($fields, $attr) = @_;
    $fields->{in_data_table}++
	if $fields->{in_data_table};
    _found_table($fields, $attr->{id})
	if $attr->{id};
    return;
}

# _start_td(hash_ref fields, hash_ref attr)
#
# Starts a TD.
#
sub _start_td {
    my($fields, $attr) = @_;
    # Don't separate cells in nested table
#TODO: Format like a table, e.g. </td> -> ' ', </tr> -> \n
    return unless _in_data($fields);
    $fields->{text} = '';
    $fields->{colspan} = $attr->{colspan} || 1;
    return;
}

# _start_th(hash_ref fields, hash_ref attr)
#
# Starts a TH and initializes {table} if necessary.
#
sub _start_th {
    my($fields, $attrs) = @_;
    _found_table($fields);
    return _start_td(@_);
}

# _start_tr(hash_ref fields, hash_ref attr, string tag)
#
# Only adds rows if rows has been initialized.
#
sub _start_tr {
    my($fields, $attr) = @_;
    return unless _in_data($fields);
    push(@{$fields->{table}->{rows}}, [])
	if $fields->{table}->{rows};
    return;
}

# _text(hash_ref fields) : string
#
# Returns the text field or dies if not defined.
#
sub _text {
    my($fields) = @_;
    my($res) = $fields->{text} || '';
    $fields->{text} = undef;
    return $res;
}

=head1 COPYRIGHT

Copyright (c) 2002 bivio Software Artisans, Inc.  All Rights Reserved.

=head1 VERSION

$Id$

=cut

1;
