#!perl -w
# Copyright (c) 2003 bivio Software, Inc.  All Rights Reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - Database upgrade

=head1 RELEASE SCOPE

Societas

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Auth::Realm;
use Bivio::Auth::RealmType;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Biz::Model::RealmOwner;
use Bivio::SQL::Connection;
use Bivio::ShellUtil;
use Bivio::Type::Date;
use Bivio::Type::DateInterval;
use Bivio::Type::DateTime;
use Bivio::Type::Honorific;

#=VARIABLES
$| = 1;

=head1 METHODS

=cut

sub main {
    my(@argv) = @_;

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
	    unless $method && $method  =~ /^_upgrade/;
    # Must be first, because pg_dump closes all db connections.
#    Bivio::Util::SQL->main('export_db');

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    _usage("$VERSION already ran")
	if ($upgrade->unauth_load(version => $VERSION))
            && !_is_special($method);

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.
    &{\&{$method}}($req);

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    })
	unless _is_special($method);
    Bivio::Agent::Task->commit($req);
    return 1;
}

#=PRIVATE SUBROUTINES

# _add_realm_roles(hashref role_map)
#
# Add new roles to realm_role_t to replace honorifics
#
sub _add_realm_roles {
    my($role_map) = @_;
    foreach my $role_key (keys %$role_map) {
        my($role_value) = $role_map->{$role_key};
	my($new_role) = Bivio::Auth::Role->$role_key->as_sql_param();
	my($old_role) = Bivio::Auth::Role->$role_value->as_sql_param();
        _do_sql(<<"EOF");
INSERT INTO realm_role_t
    (realm_id, role, permission_set)
    SELECT realm_id, $new_role, permission_set
    FROM realm_role_t
    WHERE role = $old_role
/
EOF
    }

    return;
}

# _do_sql(string sql) : statement
#
# Returns the last statement executed.
#
# Notes: This is a copy-and-paste of code from
# zoe-db-upgrade, and same as zoe-db-upgrade and
# as-db-upgrade. Also, the first part of the code
# is similar to Bivio::Util::SQL->_parse.
# Opportunities!!
#
sub _do_sql {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_honorific()
#
# Drop honorific column
#
sub _drop_honorific {
    _do_sql(<<"EOF");
ALTER TABLE realm_user_t
  DROP CONSTRAINT realm_user_t7
/
ALTER TABLE realm_user_t
DROP COLUMN honorific
/
EOF
    return;
}

# _is_special(string method) : boolean
#
# Return true if method is an explicit call to an _upgrade method.
#
sub _is_special {
    return shift =~ /^_upgrade_.+/;
}

# _map_honorifics(arrayref roles)
#
# Update roles to reflect old honorific
#
sub _map_honorifics {
    my($roles) = @_;

    foreach (@$roles) {
	my($honorific) = Bivio::Type::Honorific->$_->as_sql_param();
	my($role) = Bivio::Auth::Role->$_->as_sql_param();

	_do_sql(<<"EOF");
UPDATE realm_user_t
SET role = $role
WHERE honorific = $honorific
/
EOF
    }

    return;
}

# _upgrade(Bivio::Agent::Request req)
#
# Updates the database.
#
sub _upgrade {
    my($req) = @_;
    _upgrade_drop_honorific($req);
    _upgrade_multiple_realm_roles($req);
    print("** DONE ***\n");
    return;
}

# _upgrade_drop_honorific(Bivio::Agent::Request req)
#
# Drop honorific column from realm_user_t
#
sub _upgrade_drop_honorific {
    my($req) = @_;
    print("dropping honorific\n");
    _drop_honorific();
    return;
}

# _upgrade_drop_honorific_societas(Bivio::Agent::Request req)
#
# Map honorifics to new role and drop honorific column from realm_user_t
#
sub _upgrade_drop_honorific_societas {
    my($req) = @_;
    print("dropping honorific\n");
    my($role_map) = {
	SECRETARY => 'MEMBER',
	TREASURER => 'ACCOUNTANT',
	VICE_PRESIDENT => 'ADMINISTRATOR',
	PRESIDENT => 'ADMINISTRATOR',
    };
    _add_realm_roles($role_map);
    _map_honorifics([keys(%$role_map)]);
    _drop_honorific();
    _do_sql(<<'EOF');
ALTER TABLE realm_invite_t
DROP COLUMN honorific
/
EOF
    return;
}

# _upgrade_multiple_realm_roles(Bivio::Agent::Request req)
#
# Drop single role per realm contraint
#
sub _upgrade_multiple_realm_roles {
    my($req) = @_;
    print("dropping realm-role constraint\n");
    _do_sql(<<'EOF');
ALTER TABLE realm_role_t
  DROP CONSTRAINT realm_role_t4
/
ALTER TABLE realm_user_t
  DROP CONSTRAINT realm_user_t6
/
ALTER TABLE realm_user_t
  DROP CONSTRAINT realm_user_t1
/
ALTER TABLE realm_user_t
  ADD CONSTRAINT realm_user_t1
  PRIMARY KEY(realm_id, user_id, role)
/
EOF
    return;
}

# _usage() : NO RETURN
#
# print usage message and exit.
#
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 COPYRIGHT

Copyright (c) 2003 bivio Software, Inc.  All Rights Reserved.

=head1 VERSION

$Id$

=cut

main(@ARGV);

#Local Variables:
#mode:cperl
#End:
