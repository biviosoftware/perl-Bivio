# Copyright (c) 2005 bivio Software Artisans, Inc.  All Rights Reserved.
# $Id$
package Bivio::SQL::Statement;
use strict;
$Bivio::SQL::Statement::VERSION = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);
$_ = $Bivio::SQL::Statement::VERSION;

=head1 NAME

Bivio::SQL::Statement - smart SQL statement builder

=head1 RELEASE SCOPE

bOP

=head1 SYNOPSIS

    use Bivio::SQL::Statement;

=cut

=head1 EXTENDS

L<Bivio::UNIVERSAL>

=cut

use Bivio::UNIVERSAL;
@Bivio::SQL::Statement::ISA = ('Bivio::UNIVERSAL');

=head1 DESCRIPTION

C<Bivio::SQL::Statement>

=cut

#=IMPORTS
use Bivio::IO::Trace;

#=VARIABLES
my($_IDI) = __PACKAGE__->instance_data_index;

=head1 FACTORIES

=cut

=for html <a name="AND"></a>

=head2 static AND(any predicate, ... ) : hash_ref

Return a list of predicates joined by AND.

=cut

sub AND {
    my($proto) = shift;
    return _combine_predicates($proto, 'AND', @_);
}

=for html <a name="CROSS_JOIN"></a>

=head2 static CROSS_JOIN(any join, ...) : hash_ref

Return a CROSS JOIN (i.e. the default join when no join is specified).

=cut

sub CROSS_JOIN {
    my($proto, @joins) = @_;
    my($joins) = [@joins];
    return {
        joins => $joins,
        build => sub {
            return join(',', map({$_->{build}->(@_)} @$joins));
        },
    };
}

=for html <a name="DISTINCT"></a>

=head2 static DISTINCT(string column) : hash_ref



=cut

sub DISTINCT {
    my($proto, $column) = @_;
    return {
        distinct => $column,
	columns => [$column],
        build => sub {
            return join(' ', 'DISTINCT', _build_select_column($column, @_));
        },
    };
}

=for html <a name="EQ"></a>

=head2 static EQ(string left, string right) : hash_ref

=head2 static EQ(string left, array_ref right) : hash_ref

Return an EQ predicate.
If I<right> is an array_ref, treat right as a value, not a column.

=cut

sub EQ {
    my($proto, $left, $right) = @_;
    return _static_compare('=', $left, $right);
}

=for html <a name="GT"></a>

=head2 static GT(string left, string right) : hash_ref

=head2 static GT(string left, array_ref right) : hash_ref

Return a Greater Than predicate.

=cut

sub GT {
    my($proto, $left, $right) = @_;
    return _static_compare('>', $left, $right);
}

=for html <a name="GTE"></a>

=head2 static GTE(string left, string right) : hash_ref

=head2 static GTE(string left, array_ref right) : hash_ref

Return a Greater Than or Equal predicate.

=cut

sub GTE {
    my($proto, $left, $right) = @_;
    return _static_compare('>=', $left, $right);
}

=for html <a name="ILIKE"></a>

=head2 static ILIKE(string column, string match) : hash_ref

Return a ILIKE predicate.

=cut

sub ILIKE {
    return _like(ILIKE => @_);
}

=for html <a name="IN"></a>

=head2 static IN(string column, array_ref list) : hash_ref

Return an IN predicate.

=cut

sub IN {
    return _in('', @_);
}

=for html <a name="IS_NOT_NULL"></a>

=head2 static IS_NOT_NULL(string column) : hash_ref

Return an IS NOT NULL predicate

=cut

sub IS_NOT_NULL {
    my($proto, $column) = @_;
    return {
        column => $column,
        build => sub {
            return _build_column($column, @_) . ' IS NOT NULL';
        },
    };
}

=for html <a name="IS_NULL"></a>

=head2 static IS_NULL(string column) : hash_ref

Return an IS NULL predicate

=cut

sub IS_NULL {
    my($proto, $column) = @_;
    return {
        column => $column,
        build => sub {
            return _build_column($column, @_) . ' IS NULL';
        },
    };
}

=for html <a name="LEFT_JOIN_ON"></a>

=head2 static LEFT_JOIN_ON(string left_table, string right_table, any join_predicate) : hash_ref

Return a LEFT JOIN ON join.

=cut

sub LEFT_JOIN_ON {
    my($proto, $left_table, $right_table, $join_predicate) = @_;
    $join_predicate = _parse_predicate($proto, $join_predicate);
    return {
        left_table => $left_table,
        right_table => $right_table,
        join_predicate => $join_predicate,
        build => sub {
            return
                'LEFT JOIN ' . _build_model($right_table, @_) .
                ' ON (' . $join_predicate->{build}->(@_) . ')';
        },
    };
}

=for html <a name="LIKE"></a>

=head2 static LIKE(string column, string match) : hash_ref

Return a LIKE predicate.

=cut

sub LIKE {
    return _like(LIKE => @_);
}

=for html <a name="LT"></a>

=head2 static LT(string left, string right) : hash_ref

=head2 static LT(string left, array_ref right) : hash_ref

Return a Less Than predicate.

=cut

sub LT {
    my($proto, $left, $right) = @_;
    return _static_compare('<', $left, $right);
}

=for html <a name="LTE"></a>

=head2 static LTE(string left, string right) : hash_ref

=head2 static LTE(string left, array_ref right) : hash_ref

Return a Less Than or Equal predicate.

=cut

sub LTE {
    my($proto, $left, $right) = @_;
    return _static_compare('<=', $left, $right);
}

=for html <a name="NE"></a>

=head2 static NE(string left, string right) : hash_ref

=head2 static NE(string left, array_ref right) : hash_ref

Return an != predicate.
If I<right> is an array_ref, treat right as a value, not a column.

=cut

sub NE {
    my($proto, $left, $right) = @_;
    return _static_compare('!=', $left, $right);
}

=for html <a name="NOT_IN"></a>

=head2 static NOT_IN(string column, array_ref list) : hash_ref

Return an NOT_IN predicate.

=cut

sub NOT_IN {
    return _in(' NOT', @_);
}

=for html <a name="NOT_LIKE"></a>

=head2 static NOT_LIKE(string column, string match) : hash_ref

Return a NOT_LIKE predicate.

=cut

sub NOT_LIKE {
    return _like('NOT LIKE', @_);
}

=for html <a name="OR"></a>

=head2 OR(any predicate, ... ) : hash_ref

Return a list of predicates joined by OR.

=cut

sub OR {
    my($proto) = shift;
    return _combine_predicates($proto, 'OR', @_);
}

=for html <a name="PARENS"></a>

=head2 static PARENS(any predicate, ... ) : hash_ref

Return a single predicate grouped inside parentheses.

=cut

sub PARENS {
    my($proto, $predicate) = @_;
    return {
        predicate => $predicate,
        build => sub {
            return '(' . $predicate->{build}->(@_) . ')';
        },
    }
}

=for html <a name="SELECT_AS"></a>

=head2 static SELECT_AS(any column, string alias) : hash_ref

Return the select object

=cut

sub SELECT_AS {
    my($proto, $column, $alias) = @_;
    return {
	columns => [$column],
        build => sub {
            return _build_select_column($column, @_) . ' AS ' . $alias;
        },
    }
}

=for html <a name="SELECT_LITERAL"></a>

=head2 static SELECT_LITERAL(string literal) : hash_ref

Return the select of a literal

=cut

sub SELECT_LITERAL {
    my($proto, $literal) = @_;
    return {
	columns => [$literal],
        build => sub {$literal},
    }
}

=for html <a name="new"></a>

=head2 static new() : Bivio::SQL::Statement

Return a new instance.

=cut

sub new {
    my($proto) = @_;
    my($self) = shift->SUPER::new(@_);
    $self->[$_IDI] = {
        from => {},
        select => undef,
        where => $self->AND(),
        _models => {},
    };
    return $self;
}

=head1 METHODS

=cut

=for html <a name="build_decl_for_sql_support"></a>

=head2 build_decl_for_sql_support() : hash_ref

Return columns for ListModel

=cut

sub build_decl_for_sql_support {
    my($self) = @_;
    return {
        other => $self->[$_IDI]->{select}->{column_names},
	# HACK: but I don't know what to do about it yet
	primary_key => $self->[$_IDI]->{select}->{column_names},
    }
	if $self->[$_IDI]->{select};
    return {};
}

=for html <a name="build_for_internal_load_rows"></a>

=head2 build_for_internal_load_rows(Bivio::SQL::Support support) : (string, array_ref)

Return FROM and WHERE clauses for internal_load_rows

=cut

sub build_for_internal_load_rows {
    my($self, $support) = @_;
    _merge_statements($self, $support->get_statement());
    my($fields) = $self->[$_IDI];
    my($params) = [];
    my($where) = $fields->{where};
    return ($where->{build}->($support, $params), $params)
        unless %{$fields->{from}};
    foreach my $model (
	$fields->{select} ? () : keys(%{$support->get('models')}),
    ) {
        _add_model($self, $model);
    }
    return (
        join(' ',
	     $fields->{select} ?
		 (SELECT => $fields->{select}->{build}->($support, $params))
		 : (),
	     FROM => $self->CROSS_JOIN(
		 map($fields->{from}->{$_},
		     sort(keys(%{$fields->{from}}))),
	     )->{build}->($support, $params),
	     WHERE => $where->{build}->($support, $params),
	),
	$params,
    );
}

=for html <a name="build_select_for_sql_support"></a>

=head2 build_select_for_sql_support(Bivio::SQL::ListSupport support) : string

Build SELECT clause.

=cut

sub build_select_for_sql_support {
    my($self, $support) = @_;
    my($fields) = $self->[$_IDI];
    return join(' ',
        'SELECT', $fields->{select}->{build}->($support, []))
	if $fields->{select};
    return $support->unsafe_get('select');
}

=for html <a name="config"></a>

=head2 config(hash_ref config)

Parse and apply config data

=cut

sub config {
    my($self, $config) = @_;
    foreach my $method (keys %$config) {
	$self->$method(@{$config->{$method}});
    }
    return;
}

=for html <a name="from"></a>

=head2 from(any join, ...)

Add the join(s) to the FROM clause.
TODO: Generalize to any type of JOIN.  Currently only accepts LEFT_JOIN_ON
and a simple table name  May also just be a table.

=cut

sub from {
    my($self, @joins) = @_;
    my($models) = $self->[$_IDI]->{_models};
    foreach my $join (@joins) {
	unless (ref($join)) {
	    _add_model($self, $join);
	    next;
	}
	my($left_table) = $join->{left_table};
	my($right_table) = $join->{right_table};
	Bivio::Die->die($right_table, ': is already left joined with ',
            $models->{$right_table}->{_joined_from},
        ) if exists($models->{$right_table})
	    && exists($models->{$right_table}->{_joined_from});
	my($right) = _add_model($self, $right_table, $join);
	_add_model($self, $left_table)->{joins}->{$right_table} = $right;
	$right->{_joined_from} = $left_table;

	delete($self->[$_IDI]->{from}->{$right_table});
    }
    return $self;
}

=for html <a name="select"></a>

=head2 select(any select_item)

Add item to SELECT clause.

=cut

sub select {
    my($self, @columns) = @_;
    my($column_info) = [map({_parse_column($_)} @columns)];
    $self->[$_IDI]->{select} = {
	columns => [@$column_info],
	column_names => [map({@{$_->{columns}}} @$column_info)],
	build => sub {
	    return join(',', map({$_->{build}->(@_)} @$column_info));
	},
    };
    return $self;
}

=for html <a name="union_hack"></a>

=head2 union_hack(Bivio::SQL::Statement stmt, ...)

Add I<stmt>s to WHERE clause.  The statement has to be completely empty
at this point.

=cut

sub union_hack {
    my($self, @stmt) = @_;
    Bivio::Die->die('statement must be empty to union')
	 if @{$self->[$_IDI]->{where}->{predicates}};
    $self->[$_IDI]->{where} = {
	statements => [@stmt],
	build => sub {
	    my($support, $params) = @_;
	    return join(
		' UNION ',
		map({
		    my($s, $p) = $_->build_for_internal_load_rows($support);
		    push(@$params, @$p);
		    $s;
		} @stmt),
	    );
	},
    };
    return $self;
}

=for html <a name="where"></a>

=head2 where(any predicate, ...)

Add I<predicate>s to WHERE clause.  This condition will be ANDed
with any other existing conditions.

=cut

sub where {
    my($self, @predicates) = @_;
    foreach my $predicate (grep({$_} @predicates)) {
        push(@{$self->[$_IDI]->{where}->{predicates}},
            _parse_predicate($self, $predicate));
    }
    return $self;
}

#=PRIVATE SUBROUTINES

# _add_model(self, string model, hash_ref join) : hash_ref
#
# Add model to _models and from (if new).
# Return the hash_ref representation.
#
sub _add_model {
    my($self, $model, $join) = @_;
    my($models) = $self->[$_IDI]->{_models};
    my($joins) = {};
    my($build_model) = $join
	? $join
	: {build => sub {_build_model($model, @_)}};
    $self->[$_IDI]->{from}->{$model} = $models->{$model} = {
        joins => $joins,
	build_model => $build_model,
        build => sub {
            return
                join(' ', $build_model->{build}->(@_),
                    map({$_->{build}->(@_)}
                        map({$joins->{$_}} sort keys %$joins)));
        },
    }
        unless exists $models->{$model};

    return $models->{$model};
}

# _build_column(string column) : string
#
# Build column name.
# Understands 'Model.field', 'Model_#.field', and 'FUNC(Model.field)'
#
sub _build_column {
    my($column) = @_;
    my($func, $model, $index, $field, $paren)
	= $column =~ /^(\w+\()?(\w+?)(_\d+)?\.(\w+)(\)?)$/;
    $func ||= '';
    $index ||= '';
    $paren ||= '';
    return $func
        . Bivio::Biz::Model->get_instance($model)->get_info('table_name')
	. "$index.$field$paren";
}

# _build_column_info(string column) : hash_ref
#
# Build column information.
# Understands 'Model.field', 'Model_#.field', and 'FUNC(Model.field)'
# Returns a hash_ref with the following information:
#   column_name  (:string 'field')
#   model        (:Bivio::Biz::Model)
#   name         (:string 'Model_#.field')
#   sql_name     (:string)
#   type         (:Bivio::Type)
#
sub _build_column_info {
    my($column) = @_;
    my($func, $model_name, $index, $field, $paren)
	= $column =~ /^(\w+\()?(\w+?)(_\d+)?\.(\w+)(\)?)$/;
    $func ||= '';
    $index ||= '';
    $paren ||= '';
    my($model) = Bivio::Biz::Model->get_instance($model_name); 
    return {
        column_name => $field,
	model => $model,
	name => $column,
	sql_name => $func
            . $model->get_info('table_name') . "$index.$field$paren",
        type => $model->get_field_type($field),
    }
}

# _build_model(string model) : string
#
# Return the sql table name for the model.
# Understands 'Model' and 'Model_#'
#
sub _build_model {
    my($model_name) = @_;
    my($model, $index) = $model_name =~ /^(\w+?)(_\d+)?$/;
    my($table) = Bivio::Biz::Model->get_instance($model)
	->get_info('table_name');
    $index ||= '';
    return $table
        . ($index ? " $table$index" : '');
}

# _build_value(string column, string value, Bivio::SQL::Support support) : string
#
# Build placeholder and add value to I<params>.
#
sub _build_value {
    my($column, $value, $support, $params) = @_;
    my($func, $model, $index, $field) = $column =~ /^(\w+\()?(\w+?)(_\d+)?\.(\w+)\)?$/;
    my($t) = ($func || '') =~ /^(length|count)\(/i ? 'Bivio::Type::Number'
	: Bivio::Biz::Model->get_instance($model)->get_field_type($field);
    push(@$params, $t->to_sql_param($value));
    return $t->to_sql_value('?');
}

# _build_select_column(string column) : string
#
# Build select column name with appropriate type conversion.
#
sub _build_select_column {
    my($i) = _build_column_info(@_);
    return $i->{type}->from_sql_value($i->{sql_name});
}

# _combine_predicates(proto, string conjunctive, any predicate, ...) : hash_ref
#
# Combines the predicates with the conjunctive (AND or OR).
# OR values are wappred in parenthesis.
#
sub _combine_predicates {
      my($proto, $conjunctive) = (shift, shift);
      my($p) = [map(_parse_predicate($proto, $_), @_)];
      return {
          predicates => $p,
          build => sub {
              my($str) = join(" $conjunctive ",
  		grep($_, map($_->{build}->(@_), @$p)));
              return $conjunctive eq 'OR' ? "($str)" : $str;
          },
      };
}

# _in(string modifier, proto, string column, any values) : hash_ref
#
# Create "IN" or "NOT IN" clause
#
sub _in {
    my($modifier, undef, $column, $values) = @_;
    return {
        column => $column,
        values => $values,
        build => sub {
            return @$values
		? _build_column($column, @_)
		. "$modifier IN ("
		. join(',', map(_build_value($column, $_, @_), @$values))
		. ')'
		: $modifier ? 'TRUE' : 'FALSE';
        },
    };
}

# _like(string predicate, proto, string column, string match) : hash_ref
#
# Build a LIKE or ILIKE predicate.
# If column is a Bivio::Type::Enum, do an in-memory search on short_desc
# and subsitute an IN.
#
sub _like {
    my($predicate, $proto, $column, $match) = @_;
    my($col_info) = _build_column_info($column);
    if ($col_info->{type}->isa('Bivio::Type::Enum')) {
	$match =~ s/%/\.\*/g;
	$match =~ s/_/./g;
	my($re) = $predicate =~ /ILIKE/ ? qr/$match/i : qr/$match/;
	my($m) = $predicate =~ /^NOT/ ? 'NOT_IN' : 'IN';
	return $proto->$m(
	    $column,
	    [grep($_->get_short_desc() =~ $re,
		  $col_info->{type}->get_list())]),
    }
    else {
	return {
            build => sub {
		my($support, $params) = @_;
		push(@$params, $match);
		return $col_info->{sql_name} . " $predicate ?";
            },
	};
    };
}

# _merge_statements(self, Bivio::SQL::Statement)
#
# Merge statement data
#
sub _merge_statements {
    my($self, $other) = @_;
    return unless $other;

    # merge WHERE
    $self->where($other->[$_IDI]->{where});

    # merge FROM
    # TODO: more needs to be done here.
    foreach my $model (keys %{$other->[$_IDI]->{from}}) {
	$self->[$_IDI]->{from}->{$model} = $self->[$_IDI]->{_models}->{$model}
	    = $other->[$_IDI]->{from}->{$model}
		unless exists $self->[$_IDI]->{_models}->{$model};
    }

#     foreach my $model (keys %{$other->[$_IDI]->{_models}}) {
#         unless (grep($_ eq $model, keys %{$self->[$_IDI]->{_models}})) {
#             Bivio::Die->die('failed to merge model: ', $model);
#         }
#     }

    return;
}

# _parse_column(hash_ref column) : hash_ref
# _parse_column(string column) : hash_ref
sub _parse_column {
    my($column) = @_;
    return $column
	if ref($column) eq 'HASH';
    return {
	columns => [$column],
	build => sub {
	    return _build_column($column, @_);
	},
    };
}

# _parse_predicate(proto, any predicate) : 
#
# Parse a literal predicate, according to the following defaults:
# 1) Unspecified predicates are EQ
# 2) Unspecified lists of predicates are joined by AND
#
sub _parse_predicate {
    my($proto, $predicate) = @_;
    return $predicate
        if ref($predicate) eq 'HASH';
    Bivio::Die->die($predicate, ': not an array reference')
        unless ref($predicate) eq 'ARRAY';
    return $proto->EQ(@$predicate)
        unless ref($predicate->[0]);
    return $proto->AND(map({_parse_predicate($proto, $_)} @$predicate));
}

# _static_compare(string comp, string left, string right) : hash_ref
#
# Return a comparison predicate.
#
sub _static_compare {
    my($comp, $left, $right) = @_;
    return {
        left => $left,
        right => $right,
        build => sub {
            my($_left) = _build_column($left, @_);
            my($_right) = ref($right) eq 'ARRAY'
                ? _build_value($left, shift(@$right), @_)
                : _build_column($right, @_);
            return "$_left$comp$_right";
        },
    };
}

=head1 COPYRIGHT

Copyright (c) 2005 bivio Software Artisans, Inc.  All Rights Reserved.

=head1 VERSION

$Id$

=cut

1;
