#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Biz::Model::MGFSInstrument;
use Bivio::Collection::Attributes;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;
use Bivio::Type::Honorific;
use Bivio::Type::EntryType;

#=VARIABLES
$| = 1;

sub main {
    my(@argv) = @_;
    Bivio::IO::Config->initialize(\@argv);

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.  Avo
    &{\&{$method}}();

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::SQL::Connection->commit;

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _add_column(string table, string column, string sql_type, string value)
#
# Adds a column to the database and sets the default value.  Add constraints or
# indices, add them after this call.
#
sub _add_column {
    my($table, $column, $type, $value) = @_;
    print "Adding $table.$column\n";
    _do_sql("
ALTER TABLE $table
    ADD $column $type
/
");
    return unless defined($value);

    # Insert default values
    print "Inserting default into $table.$column\n";
    _do_sql("
update $table $column = $value
/");

    return;
}

# _do_sql(string sql) : statement
#
# Returns the last statement executed.
#
sub _do_sql {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_column(string table, string column)
#
# Drops the column.
#
sub _drop_column {
    my($table, $column) = @_;
    print "Dropping $table.$column\n";
    _do_sql("
ALTER TABLE $table
    DROP COLUMN $column
/
");
    return;
}

# _drop_constraints(string table, string column) : int
#
# Drop all the constraints on a particular table and column.
# Returns number of constraints dropped.
#
sub _drop_constraints {
    my($table, $column) = map {uc($_)} @_;
    # Find all constraints on the table
    my($statement) = _do_sql(<<"EOF");
	    SELECT user_cons_columns.constraint_name
	      FROM user_cons_columns, user_constraints
	      WHERE user_cons_columns.column_name = '$column'
	      AND user_cons_columns.table_name = '$table'
	      AND user_constraints.constraint_name
	      = user_cons_columns.constraint_name
              /
EOF
    my(@constraints);
    while (my($name) = $statement->fetchrow_array) {
	push(@constraints, $name);
    }
    $statement->finish;

    # Drop the constraints
    foreach my $c (@constraints) {
	_do_sql("ALTER TABLE $table drop constraint $c
                /");
    }
    return int(@constraints);
}

# _fix_mgfs_names(hash_ref name_map)
#
# Takes a map of (bad_name => 'good_name') and updates mgfs_instrument_t
# and instrument_t.
#
sub _fix_mgfs_names {
    my($name_map) = @_;

    my($mgfs_instrument) = Bivio::Biz::Model::MGFSInstrument->new(
	    Bivio::Agent::Request->get_current_or_new);
    foreach my $bad_name (keys(%$name_map)) {
	if ($mgfs_instrument->unsafe_load(name => $bad_name)) {

	    # this will all synchronize with the instrument_t table
	    $mgfs_instrument->update({name => $name_map->{$bad_name}});
	}
	else {
	    print(STDERR "\nmgfs_instrument name '$bad_name' not found\n");
	}
    }
    return;
}

# _modify_column(string table, string column, string type)
#
# Change the type of the column.
#
sub _modify_column {
    my($table, $column, $type) = @_;
    _do_sql("
ALTER TABLE $table MODIFY $column $type
/");
    return;
}

# _upgrade()
#
# Replace this method with the table/data manipulations.
#
sub _upgrade {

    _upgrade_purge_bad_mgfs_records();

    return;
}

# _upgrade_purge_bad_mgfs_records()
#
# Identifies and expunges instruments which aren't mgfs fundamental (ie
# they don't get daily updates).
#
# Clubs referring to these get local copies.
#
# Commits to the database on each instrument purged.
#
sub _upgrade_purge_bad_mgfs_records {

    print(STDERR "fixing primary key for mgfs tables\n");
    # add missing mgfs key constraints
    foreach my $table (qw(mgfs_balance_sheet_t mgfs_cash_flow_t
            mgfs_income_statement_t)) {
	$table = uc($table);
	_do_sql("
ALTER TABLE $table drop constraint $table"."1
/");

	_do_sql("
ALTER TABLE $table
add constraint $table"."1
primary key(mg_id, date_time, annual, quarter)
using index tablespace index_1m pctfree 70 initrans 2 storage (freelists 1)
/");
    }

    print(STDERR "scanning for slow-quote instruments\n");
    my($sth) = Bivio::SQL::Connection->execute('
            SELECT mg_id, symbol, name, instrument_id
            FROM mgfs_instrument_t
            ORDER by symbol', []);

    my($missing) = [];
    my($clubs) = {};
    while (my $row = $sth->fetchrow_arrayref) {
	# mg_id, symbol, name, instrument_id
	my($rec) = [@$row];

	unless (_has_fundamental($rec->[0])) {
	    push(@$missing, $rec);
	    _add_clubs_owning($clubs, $rec);
	}
    }

    # localize offending instruments
    foreach my $club_id (keys(%$clubs)) {
	foreach my $rec (@{$clubs->{$club_id}}) {
	    print(STDERR "converting instrument for club_id $club_id\n");
	    _make_local($club_id, $rec);
	}
    }

    print(STDERR "deleting ".int(@$missing)." slow-quote instruments\n");
    # delete the references to bad instruments in mgfs and global tables
    foreach my $rec (@$missing) {
	my($mg_id) = $rec->[0];
	my($instrument_id) = $rec->[3];
	print(STDERR ".");

	Bivio::SQL::Connection->execute('
                DELETE FROM mgfs_daily_quote_t
                WHERE mg_id=?',
		[$mg_id]);

	foreach my $table (qw(mgfs_instrument_t instrument_t)) {
	    Bivio::SQL::Connection->execute("
                    DELETE FROM $table
                    WHERE instrument_id=?",
		    [$instrument_id]);
	}

	# commit after each, it is a lot of data to delete
	# don't want rollback segment to max out
	Bivio::SQL::Connection->commit;
    }
    print(STDERR "\n");
    return;
}


# _add_clubs_owning(hash_ref clubs, string instrument_id)
#
# Adds an entry to clubs for each club which owns the instrument
# identified by the specified instrument_id.
#
sub _add_clubs_owning {
    my($clubs, $rec) = @_;
    my($sth) = Bivio::SQL::Connection->execute('
            SELECT DISTINCT(realm_owner_t.realm_id)
            FROM realm_instrument_entry_t, realm_instrument_t, realm_owner_t
            WHERE realm_instrument_entry_t.realm_instrument_id
                =realm_instrument_t.realm_instrument_id
            AND realm_instrument_t.realm_id=realm_owner_t.realm_id
            AND realm_instrument_t.instrument_id=?',
	    [$rec->[3]]);
    while (my $row = $sth->fetchrow_arrayref) {
	my($realm_id) = $row->[0];
	my ($recs) = $clubs->{$realm_id};
	unless (defined($recs)) {
	    $clubs->{$realm_id} = $recs = [];
	}
	push (@$recs, $rec);
    }
    return;
}

# _has_fundamental(string mg_id) : boolean
#
# Returns true if the specified mgfs instrument has a fundamental record.
#
sub _has_fundamental {
    my($mg_id) = @_;
    my($sth) = Bivio::SQL::Connection->execute('
            SELECT COUNT(*)
            FROM mgfs_fundamental_t
            WHERE mg_id=?',
	    [$mg_id]);
    my($result) = 0;
    while (my $row = $sth->fetchrow_arrayref) {
	$result = $row->[0] || 0;
    }
    return $result;
}

# _make_local(string club_id, array_ref rec)
#
# Copies global instrument data into the local one and severs
# the tie to the global version.
#
sub _make_local {
    my($club_id, $rec) = @_;

    use Bivio::Biz::Model::Instrument;
    use Bivio::Biz::Model::RealmInstrument;

    my($req) = Bivio::Agent::Request->get_current_or_new;

    my($instrument_id) = $rec->[3];
    my($inst) = Bivio::Biz::Model::Instrument->new($req);
    $inst->unauth_load_or_die(instrument_id => $instrument_id);

    my($realm_inst) = Bivio::Biz::Model::RealmInstrument->new($req);
    $realm_inst->unauth_load_or_die(instrument_id => $instrument_id,
	   realm_id => $club_id);

    my($new_values) = {
	instrument_id => undef,
    };
    foreach my $field (qw(fed_tax_free instrument_type name ticker_symbol
            exchange_name)) {
	$new_values->{$field} = $inst->get($field);
    }
    $realm_inst->update($new_values);
    return;
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
