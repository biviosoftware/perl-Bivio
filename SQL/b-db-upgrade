#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Auth::Realm;
use Bivio::Auth::RealmType;
use Bivio::Biz::Accounting::Tax;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Biz::Model::RealmOwner;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::ShellUtil;
use Bivio::Type::Date;
use Bivio::Type::DateInterval;
use Bivio::Type::DateTime;

#=VARIABLES
$| = 1;

sub main {
    my(@argv) = @_;

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.
    &{\&{$method}}($req);

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::Agent::Task->commit($req);

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _add_column(string table, string column, string sql_type, string value)
#
# Adds a column to the database and sets the default value.  Add constraints or
# indices, add them after this call.
#
sub _add_column {
    my($table, $column, $type, $value) = @_;
    print "Adding $table.$column\n";
    _do_sql("
ALTER TABLE $table
    ADD $column $type
/
");
    return unless defined($value);

    # Insert default values
    print "Inserting default into $table.$column\n";
    _do_sql("
update $table set $column = $value
/");

    return;
}

# _disclaimer(string user) : string
#
# Returns a disclaimer for a particular person.
#
sub _disclaimer {
    my($celeb) = @_;
    return <<"EOF";
Disclaimer: statements are opinions expressed by $celeb.
These statements are not intended to replace professional
advice. When in doubt, follow the advice of your investment, tax or
legal advisors who are familiar with your particular circumstances.
EOF
}

# _do_sql(string sql) : statement
#
# Returns the last statement executed.
#
sub _do_sql {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_column(string table, string column)
#
# Drops the column.
#
sub _drop_column {
    my($table, $column) = @_;
    print "Dropping $table.$column\n";
    _do_sql("
ALTER TABLE $table
    DROP COLUMN $column
/
");
    return;
}

# _drop_constraints(string table, string column) : int
#
# Drop all the constraints on a particular table and column.
# Returns number of constraints dropped.
#
sub _drop_constraints {
    my($table, $column) = map {uc($_)} @_;
    # Find all constraints on the table
    my($statement) = _do_sql(<<"EOF");
	    SELECT user_cons_columns.constraint_name
	      FROM user_cons_columns, user_constraints
	      WHERE user_cons_columns.column_name = '$column'
	      AND user_cons_columns.table_name = '$table'
	      AND user_constraints.constraint_name
	      = user_cons_columns.constraint_name
              /
EOF
    my(@constraints);
    while (my($name) = $statement->fetchrow_array) {
	push(@constraints, $name);
    }
    $statement->finish;

    # Drop the constraints
    foreach my $c (@constraints) {
	_do_sql("ALTER TABLE $table drop constraint $c
                /");
    }
    return int(@constraints);
}

# _init_realm_role(Bivio::Biz::Util::RealmRole rru, string perms)
#
# Accepts a configuration like in Biz::Util::RealmRole and sets for
# a particular club.
#
sub _init_realm_role {
    my($rru, $perms) = @_;
    $perms =~ s/\\//g;
    $perms =~ s/^.*b-realm-role.* edit /!/mg;
    foreach my $edit (split(/!/, $perms)) {
	next unless $edit;
	$rru->edit(split(' ', $edit));
    }
    return;
}

# _modify_column(string table, string column, string type)
#
# Change the type of the column.
#
sub _modify_column {
    my($table, $column, $type) = @_;
    _do_sql("
ALTER TABLE $table MODIFY $column $type
/");
    return;
}

# _sqlplus(string db_login, string actions) : string_ref
#
# Runs I<actions> in sqlplus with I<db_login>.
# Returns result of the execution.
#
# I<actions> will have a semicolon (;) appended to it.
#
# If any of I<actions> fails, will rollback and exit.
#
sub _sqlplus {
    my($db_login, $actions) = @_;
    my($res) = Bivio::ShellUtil::piped_exec(undef, 'su - oracle -c sqlplus',
            <<"EOF");
$db_login
set linesize 10000
set pagesize 10000
whenever sqlerror exit sql.sqlcode rollback
whenever oserror exit sql.sqlcode rollback
$actions;
disconnect
exit
EOF
    return $res;
}

sub _upgrade {
    my($req) = @_;
    _upgrade_rebuild_ec_tables($req);
    print("\n*** done ***\n");
    return;
}

# _upgrade_add_new_ec_columns(Bivio::Agent::Request req)
#
# Adds new columns to ec_payment_t and ec_subscription_t.
#
sub _upgrade_add_new_ec_columns {
    my($req) = @_;
    print("_upgrade_add_new_ec_columns\n");

    _add_column('ec_subscription_t', 'ec_payment_id', 'NUMBER(18)');
    _add_column('ec_payment_t', 'salesperson_id', 'NUMBER(18)');
    _add_column('ec_payment_t', 'service', 'NUMBER(2)');

    return;
}

# _upgrade_add_new_ec_constraints(Bivio::Agent::Request req)
#
# Adds constraints for new columns.
#
sub _upgrade_add_new_ec_constraints {
    my($req) = @_;
    print("_upgrade_add_new_ec_constraints\n");

    _do_sql('
ALTER TABLE ec_subscription_t
  add constraint ec_subscription_t1
  primary key(ec_payment_id)
  using index tablespace index_1m pctfree 50 initrans 4 storage (freelists 8)
/
ALTER TABLE ec_subscription_t
  add constraint ec_subscription_t3
  foreign key (ec_payment_id)
  references ec_payment_t(ec_payment_id)
/

ALTER TABLE ec_payment_t
  add constraint ec_payment_t7
  foreign key (salesperson_id)
  references user_t(user_id)
/
ALTER TABLE ec_payment_t modify service not null
/
ALTER TABLE ec_payment_t
  add constraint ec_payment_t6
  check (service between 0 and 6)
/
');
    return;
}

# _upgrade_create_new_ec_tables(Bivio::Agent::Request req)
#
# Creates the new ec tables.
#
sub _upgrade_create_new_ec_tables {
    my($req) = @_;
    print("_upgrade_create_new_ec_tables\n");

    _do_sql('
CREATE TABLE ec_check_payment_t (
  ec_payment_id NUMBER(18),
  realm_id NUMBER(18),
  check_number VARCHAR(100),
  institution VARCHAR(100)
)
  tablespace data_1m
  pctfree 25 pctused 70 initrans 2 storage (freelists 8)
/

CREATE TABLE ec_credit_card_payment_t (
  ec_payment_id NUMBER(18),
  realm_id NUMBER(18),
  processed_date_time DATE,
  processor_response VARCHAR2(500),
  processor_transaction_number VARCHAR2(30),
  card_number VARCHAR2(4000),
  card_expiration_date DATE,
  card_name VARCHAR2(100),
  card_zip VARCHAR2(30),
  point_of_sale NUMBER(2)
)
  tablespace data_1m
  pctfree 25 pctused 70 initrans 2 storage (freelists 8)
/

ALTER TABLE ec_check_payment_t
  add constraint ec_check_payment_t1
  primary key(ec_payment_id)
  using index tablespace index_1m pctfree 50 initrans 4 storage (freelists 8)
/
ALTER TABLE ec_credit_card_payment_t
  add constraint ec_credit_card_payment_t1
  primary key(ec_payment_id)
  using index tablespace index_1m pctfree 50 initrans 4 storage (freelists 8)
/

ALTER TABLE ec_check_payment_t modify realm_id not null
/
ALTER TABLE ec_check_payment_t
  add constraint ec_check_payment_t2
  foreign key (realm_id)
  references realm_owner_t(realm_id)
/
ALTER TABLE ec_check_payment_t
  add constraint ec_check_payment_t3
  foreign key (ec_payment_id)
  references ec_payment_t(ec_payment_id)
/
ALTER TABLE ec_check_payment_t modify check_number not null
/

ALTER TABLE ec_credit_card_payment_t modify realm_id not null
/
ALTER TABLE ec_credit_card_payment_t
  add constraint ec_credit_card_payment_t2
  foreign key (realm_id)
  references realm_owner_t(realm_id)
/
ALTER TABLE ec_credit_card_payment_t
  add constraint ec_credit_card_payment_t3
  foreign key (ec_payment_id)
  references ec_payment_t(ec_payment_id)
/
ALTER TABLE ec_credit_card_payment_t modify point_of_sale not null
/
ALTER TABLE ec_credit_card_payment_t
  add constraint ec_credit_card_payment_t5
  check (point_of_sale between 0 and 5)
/
ALTER TABLE ec_credit_card_payment_t modify card_number not null
/
ALTER TABLE ec_credit_card_payment_t modify card_expiration_date not null
/
ALTER TABLE ec_credit_card_payment_t modify card_name not null
/
ALTER TABLE ec_credit_card_payment_t modify card_zip not null
/

');
    return;
}

# _upgrade_drop_unused_ec_columns(Bivio::Agent::Request req)
#
# Drops unused ec columns from ec_subscription_t and ec_payment_t.
#
sub _upgrade_drop_unused_ec_columns {
    my($req) = @_;
    print("_upgrade_drop_unused_ec_columns\n");

    foreach my $column (qw(payment_type ec_subscription_id
            ec_subscription_start_date processed_date_time
            processor_response processor_transaction_number
            credit_card_number credit_card_expiration_date
            credit_card_name credit_card_zip )) {

	_drop_column('ec_payment_t', $column);
    }
    foreach my $column (qw(ec_subscription_id subscription_type)) {
	_drop_column('ec_subscription_t', $column);
    }
    return;
}

# _upgrade_drop_unused_ec_constraints(Bivio::Agent::Request req)
#
# Drops unused ec column constraints.
#
sub _upgrade_drop_unused_ec_constraints {
    my($req) = @_;
    print("_upgrade_drop_unused_ec_constraints\n");

    foreach my $column (qw(payment_type ec_subscription_id
            ec_subscription_start_date processed_date_time
            processor_response processor_transaction_number
            credit_card_number credit_card_expiration_date
            credit_card_name credit_card_zip )) {

	_drop_constraints('ec_payment_t', $column);
    }
    foreach my $column (qw(ec_subscription_id subscription_type)) {
	_drop_constraints('ec_subscription_t', $column);
    }
    return;
}

# _upgrade_map_columns(Bivio::Agent::Request req)
#
# Copies columns from tables into the new tables.
#
sub _upgrade_map_columns {
    my($req) = @_;
    my($sth);
    print("_upgrade_map_columns\n");

    use Bivio::Type::DateTime;
    use Bivio::Type::ECPaymentMethod;
    use Bivio::Type::ECPaymentStatus;
    use Bivio::Type::ECPointOfSale;
    use Bivio::Type::ECService;

    # foreach credit card payment, create an ec_credit_card_payment_t
    my($pd) = Bivio::Type::DateTime->from_sql_value('processed_date_time');
    my($cd) = Bivio::Type::DateTime->from_sql_value(
	'credit_card_expiration_date');
    $sth = Bivio::SQL::Connection->execute("
        SELECT ec_payment_id, realm_id, $pd, processor_response,
            processor_transaction_number, credit_card_number,
            $cd, credit_card_name, credit_card_zip
        FROM ec_payment_t
        WHERE method=?",
	[Bivio::Type::ECPaymentMethod->CREDIT_CARD->as_int]);

    while (my $row = $sth->fetchrow_arrayref) {
	my($ec_payment_id, $realm_id, $processed_date_time,
	    $processor_response, $processor_transaction_number,
	    $card_number, $card_expiration_date, $card_name,
	    $card_zip) = @$row;

	# credit card data may be missing for edited payments
	Bivio::Biz::Model->new($req, 'ECCreditCardPayment')->create({
	    ec_payment_id => $ec_payment_id,
	    realm_id => $realm_id,
	    processed_date_time => $processed_date_time,
	    processor_response => $processor_response,
	    processor_transaction_number => $processor_transaction_number,
	    card_number => Bivio::Type::CreditCardNumber->from_sql_column(
		$card_number) || 'xx',
	    card_expiration_date => $card_expiration_date
	        || Bivio::Type::Date->now,
	    card_name => $card_name || 'xx',
	    card_zip => $card_zip || 'xx',
	    point_of_sale => Bivio::Type::ECPointOfSale->INTERNET,
	});
    }

    # foreach check payment, create an ec_check_payment_t
    $sth = Bivio::SQL::Connection->execute("
        SELECT ec_payment_id, realm_id, remark
        FROM ec_payment_t
        WHERE method=?",
	[Bivio::Type::ECPaymentMethod->BANK_CHECK->as_int]);

    while (my $row = $sth->fetchrow_arrayref) {
	my($ec_payment_id, $realm_id, $remark) = @$row;
	# use the remark for the check_number field
	if (defined($remark)) {
	    $remark =~ s/\n/ /g;
	    $remark =~ s/\r/ /g;
	}

	Bivio::Biz::Model->new($req, 'ECCheckPayment')->create({
	    ec_payment_id => $ec_payment_id,
	    realm_id => $realm_id,
	    check_number => $remark || 'xx',
	});
    }

    # foreach subscription find latest ec_payment_id
    # or create a NO_PAYMENT ec_payment_t record and use that
    my($no_payment_creation_date_time) = Bivio::Type::DateTime->now;
    my($bivio_user_id) = Bivio::SQL::Connection->execute_one_row('
        SELECT realm_id
        FROM realm_owner_t
        WHERE name=?',
	['bivio'])->[0];
    $sth = Bivio::SQL::Connection->execute('
        SELECT ec_subscription_id, realm_id
        FROM ec_subscription_t',
	[]);

    while (my $row = $sth->fetchrow_arrayref) {
	my($ec_subscription_id, $realm_id) = @$row;
	my($ec_payment_id);

	my($sth2) = Bivio::SQL::Connection->execute('
            SELECT MAX(ec_payment_id)
            FROM ec_payment_t
            WHERE ec_subscription_id=?',
	    [$ec_subscription_id]);
	while (my $row = $sth2->fetchrow_arrayref) {
	    $ec_payment_id = $row->[0];
	}

	unless ($ec_payment_id) {
	    $ec_payment_id = Bivio::Biz::Model->new($req, 'ECPayment')
		->create({
		    realm_id => $realm_id,
		    user_id => $bivio_user_id,
		    creation_date_time => $no_payment_creation_date_time,
		    amount => 0,
		    method => Bivio::Type::ECPaymentMethod->NO_PAYMENT,
		    status => Bivio::Type::ECPaymentStatus->CAPTURED,
		    service => Bivio::Type::ECService->FREE_TRIAL,
		    description => 'Free Trial',
		})->get('ec_payment_id')
	}
	Bivio::SQL::Connection->execute('
            UPDATE ec_subscription_t
            SET ec_payment_id=?
            WHERE ec_subscription_id=?',
	    [$ec_payment_id, $ec_subscription_id]);
    }

    # foreach payment, determine service from ec_subscription_t
    $sth = Bivio::SQL::Connection->execute('
        SELECT ec_payment_id, ec_subscription_id
        FROM ec_payment_t
        WHERE service IS NULL',
	[]);

    while (my $row = $sth->fetchrow_arrayref) {
	my($ec_payment_id, $ec_subscription_id) = @$row;
	my($subscription_type);

	if ($ec_subscription_id) {
	    my($sth2) = Bivio::SQL::Connection->execute('
                SELECT subscription_type
                FROM ec_subscription_t
                WHERE ec_subscription_id=?',
		[$ec_subscription_id]);

	    while (my $row = $sth2->fetchrow_arrayref) {
		$subscription_type = $row->[0];
	    }
	}
	$subscription_type ||= 0;

	Bivio::SQL::Connection->execute('
            UPDATE ec_payment_t
            SET service=?
            WHERE ec_payment_id=?',
	    [$subscription_type, $ec_payment_id]);
    }

    Bivio::SQL::Connection->execute('
        UPDATE ec_payment_t
        SET service=0
        WHERE service IS NULL',
	[]);

    return;
}

# _upgrade_rebuild_ec_tables(Bivio::Agent::Request req)
#
# Creates new EC tables and maps current values into the new tables.
#
sub _upgrade_rebuild_ec_tables {
    my($req) = @_;
    _upgrade_create_new_ec_tables($req);
    _upgrade_add_new_ec_columns($req);
    _upgrade_drop_unused_ec_constraints($req);
    _upgrade_map_columns($req);
    _upgrade_drop_unused_ec_columns($req);
    _upgrade_add_new_ec_constraints($req);
    return;
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
