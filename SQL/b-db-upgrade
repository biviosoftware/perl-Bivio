#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Collection::Attributes;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;

#=VARIABLES

sub main {
    my(@argv) = @_;
    Bivio::IO::Config->initialize(\@argv);

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
#TODO: Change this back to "eq 'upgrade'"
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.  Avo
    &{\&{$method}}();

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::SQL::Connection->commit;

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _do(string sql) : statement
#
# Returns the last statement executed.
#
sub _do {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_constraints(string table, string column)
#
# Drop all the constraints on a particular table and column
#
sub _drop_constraints {
    my($table, $column) = map {uc($_)} @_;
    # Find all constraints on the table
    my($statement) = _do(<<"EOF");
	    SELECT user_cons_columns.constraint_name
	      FROM user_cons_columns, user_constraints
	      WHERE user_cons_columns.column_name = '$column'
	      AND user_cons_columns.table_name = '$table'
	      AND user_constraints.constraint_name
	      = user_cons_columns.constraint_name
              /
EOF
    my(@constraints);
    while (my($name) = $statement->fetchrow_array) {
	push(@constraints, $name);
    }
    $statement->finish;

    # Drop the constraints
    foreach my $c (@constraints) {
	_do("ALTER TABLE $table drop constraint $c
                /");
    }
    return;
}

# _upgrade()
#
# Replace this method with the table/data manipulations.
#
sub _upgrade {

    use Bivio::Agent::Request;
    use Bivio::Auth::Role;
    use Bivio::Biz::Model::RealmInvite;
    use Bivio::Type::Date;
    use Bivio::Type::EntryType;
    use Bivio::Type::EntryClass;

    # fixes any existing payments where the valuation date > transaction date
    my($sth) = Bivio::SQL::Connection->execute('
            SELECT realm_transaction_t.realm_id,
                '.Bivio::Type::Date->from_sql_value(
			'realm_transaction_t.date_time').',
                member_entry_t.entry_id
            FROM realm_transaction_t, entry_t, member_entry_t
            WHERE realm_transaction_t.realm_transaction_id
                =entry_t.realm_transaction_id
            AND entry_t.entry_id=member_entry_t.entry_id
            AND realm_transaction_t.date_time < member_entry_t.valuation_date',
	    []);
    while (my $row = $sth->fetchrow_arrayref) {
	my($realm_id, $date, $entry_id) = @$row;
	Bivio::SQL::Connection->execute('
                UPDATE member_entry_t
                SET valuation_date='.Bivio::Type::Date->to_sql_value('?').'
                WHERE realm_id=?
                AND entry_id=?',
		[$date, $realm_id, $entry_id]);
    }

    # add new column realm_invite_t.realm_user_id
    # update this column for outstanding shadow member invites
    my($invite) = Bivio::Biz::Model::RealmInvite->new(
	    Bivio::Agent::Request->get_current_or_new);

    _do('
ALTER TABLE realm_invite_t
  add realm_user_id NUMBER(18)
/
');

    _do('
CREATE INDEX realm_invite_realm_user_i ON realm_invite_t (
  realm_user_id
)
  storage (initial 10m next 10m minextents 1 maxextents 500 pctincrease 0)
  tablespace realm_indx
/
');

    _do('
ALTER TABLE realm_invite_t
  add foreign key (realm_user_id)
    references user_t(user_id)
/
');

    $sth = Bivio::SQL::Connection->execute('
            SELECT realm_id, email
            FROM email_t
            WHERE email like \'%:%\'', []);
    while (my $row = $sth->fetchrow_arrayref) {
	my($user_id, $shadow_email) = @$row;
	unless ($shadow_email =~ /^(.+):(\d+)$/) {
	    print(STDERR "\nskipping email $shadow_email");
	    next;
	}
	my($email, $club_id) = ($1, $2);
	# get the invite for the email/club
	$invite->unauth_load(realm_id => $club_id, email => $email)
		|| die("couldn't load invite for $shadow_email");
	$invite->update({
	    realm_user_id => $user_id
	});
    }

    # set user_t.last_name <-- realm_owner_t.name
    # if first, middle and last are null
    $sth = Bivio::SQL::Connection->execute('
            SELECT realm_owner_t.name, user_t.user_id
            FROM realm_owner_t, user_t
            WHERE realm_owner_t.realm_id=user_t.user_id
            AND user_t.first_name IS NULL
            AND user_t.middle_name IS NULL
            AND user_t.last_name IS NULL', []);
    while (my $row = $sth->fetchrow_arrayref) {
	my($name, $user_id) = @$row;
	Bivio::SQL::Connection->execute('
                UPDATE user_t
                SET last_name=?
                WHERE user_id=?',
		[$name, $user_id]);
    }

    # add new columns user_t.first_name_sort, last_name_sort, middle_name_sort
    # populate with existing data
    _do('
ALTER TABLE user_t
  add first_name_sort VARCHAR2(30)
/
ALTER TABLE user_t
  add middle_name_sort VARCHAR2(30)
/
ALTER TABLE user_t
  add last_name_sort VARCHAR2(30)
/
');

    $sth = Bivio::SQL::Connection->execute('
            SELECT user_id, first_name, middle_name, last_name
            FROM user_t', []);
    while (my $row = $sth->fetchrow_arrayref) {
	my($user_id, $first_name, $middle_name, $last_name) = @$row;
	my($update) = '';
	$update .= 'first_name_sort=lower(first_name),' if ($first_name);
	$update .= 'middle_name_sort=lower(middle_name),' if ($middle_name);
	$update .= 'last_name_sort=lower(last_name),' if ($last_name);
	if ($update) {
	    chop($update);
	    Bivio::SQL::Connection->execute('
                    UPDATE user_t
                    SET '.$update.'
                    WHERE user_id=?',
		    [$user_id]);
	}
    }

    # make space for the new Withdrawn role
    # add one to roles after it, Withdrawn comes after USER
    foreach my $table (qw(realm_user_t realm_invite_t realm_role_t)) {

	_drop_constraints($table, 'role');
	_do("
ALTER TABLE $table modify role not null
/
ALTER TABLE $table add check (role between 1 and 7)
/
");

	Bivio::SQL::Connection->execute("
                UPDATE $table
                SET role = role + 1
                WHERE role > ?",
		[Bivio::Auth::Role::USER->as_int]);
    }

    # set any guests with transactions to member
    Bivio::SQL::Connection->execute('
            UPDATE realm_user_t
            SET role=?, title=?
            WHERE role=?
            AND EXISTS (
                SELECT member_entry_t.entry_id
                FROM member_entry_t
                WHERE member_entry_t.realm_id=realm_user_t.realm_id
                AND member_entry_t.user_id=realm_user_t.user_id)
            AND realm_user_t.realm_id != realm_user_t.user_id',
	    [
		Bivio::Auth::Role::MEMBER->as_int,
		'Member',
		Bivio::Auth::Role::GUEST->as_int,
	    ]);

    # set withdrawn member's role to withdrawn
    # easyware only allow one full withdrawal per member, so this is OK
    Bivio::SQL::Connection->execute('
            UPDATE realm_user_t
            SET role=?, title=?
            WHERE EXISTS (
                SELECT realm_transaction_t.realm_transaction_id
                FROM realm_transaction_t, entry_t, member_entry_t
                WHERE realm_transaction_t.realm_transaction_id
                    =entry_t.realm_transaction_id
                AND entry_t.entry_id=member_entry_t.entry_id
                AND member_entry_t.user_id=realm_user_t.user_id
                AND entry_t.entry_type in (?, ?))
            AND realm_user_t.realm_id != realm_user_t.user_id',
	    [
		Bivio::Auth::Role::WITHDRAWN->as_int,
		'Withdrawn',
		Bivio::Type::EntryType::MEMBER_WITHDRAWAL_FULL_CASH->as_int,
		Bivio::Type::EntryType::MEMBER_WITHDRAWAL_FULL_STOCK->as_int,
	    ]);

    return;
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
