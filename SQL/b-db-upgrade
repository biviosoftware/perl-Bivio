#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Collection::Attributes;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;

#=VARIABLES

sub main {
    my(@argv) = @_;
    Bivio::IO::Config->initialize(\@argv);

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
#TODO: Change this back to "eq 'upgrade'"
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.  Avo
    &{\&{$method}}();

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::SQL::Connection->commit;

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _do(string sql) : statement
#
# Returns the last statement executed.
#
sub _do {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _upgrade()
#
# Replace this method with the table/data manipulations.
#
sub _upgrade {
    use Bivio::Biz::Util::RealmInvite;

    my($count) = Bivio::Biz::Util::RealmInvite->expire(1);
    print STDERR "Deleting $count invites\n";
    _do(<<'EOF');
-- Add the column
ALTER TABLE realm_invite_t add user_id NUMBER(18)
/
-- Make sure user_id is initialized to something.
-- This will bridge current uses.
UPDATE realm_invite_t set user_id = realm_id
/
-- from realm_constraints.sql
ALTER TABLE realm_invite_t modify user_id not null
/
-- from realm_indices.sql
CREATE INDEX realm_invite_realm_i ON realm_invite_t (
  realm_id
)
  storage (initial 10m next 10m minextents 1 maxextents 500 pctincrease 0)
  tablespace realm_indx
/

CREATE INDEX realm_invite_user_i ON realm_invite_t (
  user_id
)
  storage (initial 10m next 10m minextents 1 maxextents 500 pctincrease 0)
  tablespace realm_indx
/
--
-- connect_survey_t
--
ALTER TABLE connect_survey_t add primary key(realm_id)
  using index tablespace realm_indx
  storage (initial 10m NEXT 10m minextents 1 maxextents 500 pctincrease 0)
/
ALTER TABLE connect_survey_t
  add foreign key (realm_id)
    references realm_owner_t(realm_id)
/
ALTER TABLE connect_survey_t modify experience not null
/
ALTER TABLE connect_survey_t t add check (experience between 0 and 3)
/
ALTER TABLE connect_survey_t modify contribution not null
/
ALTER TABLE connect_survey_t t add check (contribution between 0 and 3)
/
ALTER TABLE connect_survey_t modify age_range not null
/
ALTER TABLE connect_survey_t t add check (age_range between 0 and 4)
/
ALTER TABLE connect_survey_t modify vicinity not null
/
ALTER TABLE connect_survey_t t add check (vicinity between 0 and 4)
/
ALTER TABLE connect_survey_t modify risk not null
/
ALTER TABLE connect_survey_t t add check (risk between 0 and 4)
/
ALTER TABLE connect_survey_t modify outlook not null
/
ALTER TABLE connect_survey_t t add check (outlook between 0 and 4)
/
EOF
    _upgrade_connect();
    return;
}

# _upgrade_connect()
#
# Special for connect_survey_t
#
sub _upgrade_connect {
    _do(<<'EOF');
CREATE TABLE connect_survey_t (
  realm_id NUMBER(18),
  experience NUMBER(2),
  contribution NUMBER(2),
  age_range NUMBER(2),
  vicinity NUMBER(2),
  risk NUMBER(2),
  outlook NUMBER(2)
)
  storage (initial 10m next 10m minextents 1 maxextents 500 pctincrease 0)
  tablespace realm_data
/
EOF
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
