#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Biz::Model::MGFSInstrument;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;

#=VARIABLES
$| = 1;

sub main {
    my(@argv) = @_;

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.  Avo
    &{\&{$method}}();

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::SQL::Connection->commit;

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _add_column(string table, string column, string sql_type, string value)
#
# Adds a column to the database and sets the default value.  Add constraints or
# indices, add them after this call.
#
sub _add_column {
    my($table, $column, $type, $value) = @_;
    print "Adding $table.$column\n";
    _do_sql("
ALTER TABLE $table
    ADD $column $type
/
");
    return unless defined($value);

    # Insert default values
    print "Inserting default into $table.$column\n";
    _do_sql("
update $table $column = $value
/");

    return;
}

# _do_sql(string sql) : statement
#
# Returns the last statement executed.
#
sub _do_sql {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_column(string table, string column)
#
# Drops the column.
#
sub _drop_column {
    my($table, $column) = @_;
    print "Dropping $table.$column\n";
    _do_sql("
ALTER TABLE $table
    DROP COLUMN $column
/
");
    return;
}

# _drop_constraints(string table, string column) : int
#
# Drop all the constraints on a particular table and column.
# Returns number of constraints dropped.
#
sub _drop_constraints {
    my($table, $column) = map {uc($_)} @_;
    # Find all constraints on the table
    my($statement) = _do_sql(<<"EOF");
	    SELECT user_cons_columns.constraint_name
	      FROM user_cons_columns, user_constraints
	      WHERE user_cons_columns.column_name = '$column'
	      AND user_cons_columns.table_name = '$table'
	      AND user_constraints.constraint_name
	      = user_cons_columns.constraint_name
              /
EOF
    my(@constraints);
    while (my($name) = $statement->fetchrow_array) {
	push(@constraints, $name);
    }
    $statement->finish;

    # Drop the constraints
    foreach my $c (@constraints) {
	_do_sql("ALTER TABLE $table drop constraint $c
                /");
    }
    return int(@constraints);
}

# _fix_mgfs_names(hash_ref name_map)
#
# Takes a map of (bad_name => 'good_name') and updates mgfs_instrument_t
# and instrument_t.
#
sub _fix_mgfs_names {
    my($name_map) = @_;

    my($mgfs_instrument) = Bivio::Biz::Model::MGFSInstrument->new(
	    Bivio::Agent::Request->get_current_or_new);
    foreach my $bad_name (keys(%$name_map)) {
	if ($mgfs_instrument->unsafe_load(name => $bad_name)) {

	    # this will all synchronize with the instrument_t table
	    $mgfs_instrument->update({name => $name_map->{$bad_name}});
	}
	else {
	    print(STDERR "\nmgfs_instrument name '$bad_name' not found\n");
	}
    }
    return;
}

# _modify_column(string table, string column, string type)
#
# Change the type of the column.
#
sub _modify_column {
    my($table, $column, $type) = @_;
    _do_sql("
ALTER TABLE $table MODIFY $column $type
/");
    return;
}

# _upgrade()
#
# Replace this method with the table/data manipulations.
#
sub _upgrade {

    use Bivio::Agent::Request;
    use Bivio::Auth::Realm;
    use Bivio::Auth::RealmType;
    use Bivio::Biz::Accounting::AllocationCache;
    use Bivio::Biz::Accounting::MemberBasis;
    use Bivio::Biz::Accounting::Tax;
    use Bivio::Biz::Model::MGFSDailyQuote;
    use Bivio::Biz::Model::RealmOwner;
    use Bivio::Type::Date;
    use Bivio::Type::DateTime;
    use Bivio::Type::TaxCategory;

    print("Recalculating withdrawal realized gain\n");
    my($req) = Bivio::Agent::Request->get_current_or_new;
    my($realm) = Bivio::Biz::Model::RealmOwner->new($req);

    my($sth) = Bivio::SQL::Connection->execute('
            SELECT realm_id
            FROM realm_owner_t
            WHERE realm_type=?
            ORDER BY name',
	    [Bivio::Auth::RealmType->CLUB->as_int]);
    while (my $row = $sth->fetchrow_arrayref) {
	my($realm_id) = $row->[0];
	$realm->unauth_load_or_die(realm_id => $realm_id);
	print("\t".$realm->get('name')."\n");
	$req->set_realm(Bivio::Auth::Realm->new($realm));

	Bivio::Biz::Accounting::AllocationCache->new($req)->validate;

	# redo the realized gain and cost basis adjustment
	Bivio::SQL::Connection->execute('
                DELETE FROM member_allocation_t
                WHERE tax_category IN (?,?)
                AND realm_id=?',
		[Bivio::Type::TaxCategory->MEMBER_REALIZED_GAIN->as_int,
			Bivio::Type::TaxCategory->NOT_TAXABLE->as_int,
			$realm->get('realm_id')]);

	Bivio::Biz::Accounting::MemberBasis->calculate_all_realized_gain($req);
    }

    print("updating decimal AMEX quotes, 8/28/2000 - 9/22/2000\n");

    # data from Yahoo (couldn't simply round value, could be off by 1 cent)
    # (ticker mg_id
    # (date open high low close)+
    # )+
    my($data) = <<'EOF';
MEGA 00002883
9/22/2000 48.75 49.24 48.70 49.24
9/21/2000 49.10 49.25 48.85 48.85
9/20/2000 49.00 49.21 48.90 49.21
9/19/2000 48.80 49.00 48.79 49.00
9/18/2000 49.50 49.50 48.70 48.70
9/15/2000 50.35 50.84 49.40 49.40
9/14/2000 53.00 53.01 51.51 51.85
9/13/2000 53.04 53.49 53.00 53.00
9/12/2000 52.31 53.50 52.24 53.04
9/11/2000 52.74 52.75 52.30 52.30
9/08/2000 52.95 52.96 52.69 52.70
9/07/2000 52.26 52.90 52.26 52.70
9/06/2000 51.90 52.21 51.90 52.19
9/05/2000 52.55 52.55 51.65 51.65
9/01/2000 51.60 52.45 51.55 52.45
8/31/2000 50.90 51.80 50.90 51.50
8/30/2000 50.95 50.95 50.76 50.90
8/29/2000 50.70 51.10 50.50 51.01
8/28/2000 51.65 51.68 50.60 50.74
RBC 00007429
9/22/2000 16.87 17.06 16.87 16.92
9/21/2000 17.00 17.05 16.88 16.88
9/20/2000 17.00 17.00 16.87 16.87
9/19/2000 17.05 17.05 16.87 16.90
9/18/2000 17.25 17.35 17.00 17.13
9/15/2000 16.88 17.29 16.88 17.29
9/14/2000 17.00 17.10 16.95 16.96
9/13/2000 17.15 17.25 16.90 16.90
9/12/2000 17.05 17.30 17.05 17.15
9/11/2000 16.92 17.20 16.85 17.02
9/08/2000 16.90 17.10 16.90 16.92
9/07/2000 17.10 17.15 16.88 16.88
9/06/2000 16.88 17.00 16.88 16.94
9/05/2000 17.30 17.50 17.00 17.00
9/01/2000 17.17 17.25 17.10 17.20
8/31/2000 17.10 17.28 17.10 17.25
8/30/2000 16.75 16.95 16.75 16.90
8/29/2000 16.75 17.00 16.20 16.75
8/28/2000 16.75 17.20 16.51 16.75
PMD 00021559
9/22/2000 5.00 5.05 4.90 5.05
9/21/2000 5.00 5.02 5.00 5.02
9/20/2000 4.95 5.00 4.94 5.00
9/19/2000 4.95 5.00 4.90 5.00
9/18/2000 4.90 4.90 4.90 4.90
9/15/2000 5.00 5.05 4.95 4.95
9/14/2000 5.00 5.03 5.00 5.00
9/13/2000 4.75 5.06 4.70 5.00
9/12/2000 4.75 4.76 4.75 4.76
9/11/2000 4.65 4.70 4.65 4.70
9/08/2000 4.75 4.75 4.70 4.70
9/07/2000 4.69 4.80 4.69 4.80
9/06/2000 4.65 4.65 4.64 4.64
9/05/2000 4.62 4.70 4.62 4.70
9/01/2000 4.70 4.70 4.70 4.70
8/31/2000 4.66 4.75 4.66 4.70
8/30/2000 4.70 4.74 4.61 4.74
8/29/2000 4.60 4.67 4.60 4.64
8/28/2000 4.63 4.70 4.63 4.70
GBT 00040587
9/22/2000 5.74 5.85 5.26 5.75
9/21/2000 6.25 6.28 5.25 5.84
9/20/2000 7.40 7.40 6.10 6.30
9/19/2000 7.00 7.34 7.00 7.25
9/18/2000 8.01 8.14 7.50 7.50
9/15/2000 8.00 8.20 7.75 8.19
9/14/2000 7.70 8.18 7.55 8.00
9/13/2000 7.12 8.40 7.05 7.90
9/12/2000 7.70 7.95 7.11 7.33
9/11/2000 8.99 8.99 7.50 7.74
9/08/2000 9.00 9.00 8.60 8.95
9/07/2000 9.00 9.10 8.95 9.03
9/06/2000 9.15 9.28 8.65 8.95
9/05/2000 9.80 9.80 9.10 9.25
9/01/2000 9.90 9.99 9.75 9.90
8/31/2000 9.95 9.95 9.70 9.95
8/30/2000 9.80 10.12 9.75 9.85
8/29/2000 9.80 9.99 9.75 9.85
8/28/2000 10.00 10.00 9.82 9.93
ONT 00041507
9/22/2000 2.80 2.99 2.75 2.99
9/21/2000 3.00 3.05 2.77 2.80
9/20/2000 3.11 3.12 2.87 3.04
9/19/2000 3.08 3.20 3.02 3.10
9/18/2000 3.30 3.34 3.05 3.08
9/15/2000 3.49 3.50 3.10 3.35
9/14/2000 3.07 3.50 3.01 3.47
9/13/2000 3.10 3.10 3.00 3.07
9/12/2000 3.45 3.45 3.15 3.20
9/11/2000 3.65 3.70 3.45 3.55
9/08/2000 3.70 3.80 3.65 3.68
9/07/2000 3.65 3.80 3.65 3.74
9/06/2000 3.95 4.00 3.66 3.70
9/05/2000 3.95 4.00 3.65 3.85
9/01/2000 3.55 3.65 3.52 3.65
9/01/2000 3.55 3.65 3.52 3.65
8/31/2000 3.40 3.60 3.35 3.48
8/30/2000 3.60 3.60 3.00 3.40
8/29/2000 3.50 3.75 3.50 3.60
8/28/2000 3.41 3.49 3.25 3.41
EMA 00043074
9/22/2000 8.00 8.35 7.90 8.35
9/21/2000 8.30 8.45 8.00 8.05
9/20/2000 8.30 8.40 8.18 8.30
9/19/2000 8.45 8.45 8.00 8.19
9/18/2000 9.00 9.00 8.20 8.65
9/15/2000 8.70 9.30 8.45 9.08
9/14/2000 8.95 9.10 8.70 8.80
9/13/2000 9.02 9.25 8.54 9.00
9/12/2000 9.30 9.33 9.01 9.03
9/11/2000 9.20 9.55 9.15 9.30
9/08/2000 9.25 9.25 9.00 9.11
9/07/2000 9.09 9.25 9.02 9.25
9/06/2000 9.45 9.45 9.01 9.09
9/05/2000 9.45 10.15 9.40 9.56
9/01/2000 9.65 9.74 9.50 9.51
8/31/2000 10.75 10.85 9.50 9.69
8/30/2000 10.75 11.25 10.70 10.70
8/29/2000 10.00 11.00 9.80 10.50
8/28/2000 8.85 9.70 8.80 9.66
EOF

    my($quote) = Bivio::Biz::Model::MGFSDailyQuote->new($req);

    my($mg_id);
    foreach my $line (split("\n", $data)) {
	if ($line =~ /^(\w+)\s(\d+)$/) {
	    print("\t$1\n");
	    $mg_id = $2;
	}
	elsif ($line =~ /^(\S+)\s(\S+)\s(\S+)\s(\S+)\s(\S+)$/) {
	    die("missing mg_id") unless $mg_id;
	    my($date) = $1;
	    my($prices) = {
		mg_id => $mg_id,
		open => $2,
		high => $3,
		low => $4,
		close => $5,
	    };

	    $date = Bivio::Type::Date->from_literal($date);
	    die("illegal date") unless $date;
	    $prices->{date_time} = $date;

	    $quote->load(mg_id => $mg_id, date_time => $date);
	    $quote->update($prices);
	}
	else {
	    die("unhandled line $line");
	}
    }

    print("\n*** done ***\n");
    return;
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
