#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Biz::Model::MGFSInstrument;
use Bivio::Collection::Attributes;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;



#=VARIABLES

sub main {
    my(@argv) = @_;
    Bivio::IO::Config->initialize(\@argv);

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
#TODO: Change this back to "eq 'upgrade'"
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.  Avo
    &{\&{$method}}();

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::SQL::Connection->commit;

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _do_sql(string sql) : statement
#
# Returns the last statement executed.
#
sub _do_sql {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_constraints(string table, string column)
#
# Drop all the constraints on a particular table and column
#
sub _drop_constraints {
    my($table, $column) = map {uc($_)} @_;
    # Find all constraints on the table
    my($statement) = _do_sql(<<"EOF");
	    SELECT user_cons_columns.constraint_name
	      FROM user_cons_columns, user_constraints
	      WHERE user_cons_columns.column_name = '$column'
	      AND user_cons_columns.table_name = '$table'
	      AND user_constraints.constraint_name
	      = user_cons_columns.constraint_name
              /
EOF
    my(@constraints);
    while (my($name) = $statement->fetchrow_array) {
	push(@constraints, $name);
    }
    $statement->finish;

    # Drop the constraints
    foreach my $c (@constraints) {
	_do_sql("ALTER TABLE $table drop constraint $c
                /");
    }
    return;
}

# _fix_mgfs_names(hash_ref name_map)
#
# Takes a map of (bad_name => 'good_name') and updates mgfs_instrument_t
# and instrument_t.
#
sub _fix_mgfs_names {
    my($name_map) = @_;

    my($mgfs_instrument) = Bivio::Biz::Model::MGFSInstrument->new(
	    Bivio::Agent::Request->get_current_or_new);
    foreach my $bad_name (keys(%$name_map)) {
	if ($mgfs_instrument->unsafe_load(name => $bad_name)) {

	    # this will all synchronize with the instrument_t table
	    $mgfs_instrument->update({name => $name_map->{$bad_name}});
	}
	else {
	    print(STDERR "\nmgfs_instrument name '$bad_name' not found\n");
	}
    }
    return;
}

# _upgrade()
#
# Replace this method with the table/data manipulations.
#
sub _upgrade {

    use Bivio::Auth::RealmType;
    use Bivio::Agent::Request;
    use Bivio::Biz::Model::RealmOwner;
    use Bivio::Data::EW::ClubImporter;
    use Bivio::Type::EntryType;

    # add start_date to club_t
    _do_sql('
ALTER TABLE club_t
    ADD start_date DATE
/
');

    # add country to realm_instrument_t
    _do_sql('
ALTER TABLE realm_instrument_t
    ADD country CHAR(2)
/
');

    # create the tax_1065_t and tax_k1_t tables
    _do_sql('
CREATE TABLE tax_1065_t (
  realm_id NUMBER(18),
  fiscal_end_date DATE,
  partnership_type NUMBER(2),
  partner_is_partnership NUMBER(1),
  partnership_is_partner NUMBER(1),
  consolidated_audit NUMBER(1),
  publicly_traded NUMBER(1),
  tax_shelter NUMBER(1),
  foreign_account_country CHAR(2),
  foreign_trust NUMBER(1),
  return_type NUMBER(2),
  irs_center NUMBER(3),
  allocation_method NUMBER(2)
)
  storage (initial 10m next 10m minextents 1 maxextents 500 pctincrease 0)
  tablespace realm_data
/

CREATE TABLE tax_k1_t (
  realm_id NUMBER(18),
  user_id NUMBER(18),
  fiscal_end_date DATE,
  entity_type NUMBER(3),
  partner_type NUMBER(2),
  foreign_partner NUMBER(1)
)
  storage (initial 10m next 10m minextents 1 maxextents 500 pctincrease 0)
  tablespace realm_data
/

--
-- tax_1065_t
--
ALTER TABLE tax_1065_t ADD primary key(realm_id, fiscal_end_date)
  using index tablespace realm_indx
  storage (initial 10m NEXT 10m minextents 1 maxextents 500 pctincrease 0)
/
ALTER TABLE tax_1065_t
  add foreign key (realm_id)
    references realm_owner_t(realm_id)
/
ALTER TABLE tax_1065_t add check (partner_is_partnership between 0 and 1)
/
ALTER TABLE tax_1065_t add check (partnership_is_partner between 0 and 1)
/
ALTER TABLE tax_1065_t add check (consolidated_audit between 0 and 1)
/
ALTER TABLE tax_1065_t add check (publicly_traded between 0 and 1)
/
ALTER TABLE tax_1065_t add check (tax_shelter between 0 and 1)
/
ALTER TABLE tax_1065_t add check (foreign_trust between 0 and 1)
/
ALTER TABLE tax_1065_t add check (partnership_type between 0 and 5)
/
ALTER TABLE tax_1065_t add check (return_type between 0 and 4)
/
ALTER TABLE tax_1065_t add check (allocation_method between 1 and 2)
/
ALTER TABLE tax_1065_t modify partner_is_partnership not null
/
ALTER TABLE tax_1065_t modify partnership_is_partner not null
/
ALTER TABLE tax_1065_t modify consolidated_audit not null
/
ALTER TABLE tax_1065_t modify publicly_traded not null
/
ALTER TABLE tax_1065_t modify tax_shelter not null
/
ALTER TABLE tax_1065_t modify foreign_trust not null
/
ALTER TABLE tax_1065_t modify return_type not null
/
ALTER TABLE tax_1065_t add check (irs_center between 0 and 10)
/
ALTER TABLE tax_1065_t modify allocation_method not null
/

--
-- tax_k1_t
--
ALTER TABLE tax_k1_t ADD primary key(realm_id, user_id, fiscal_end_date)
  using index tablespace realm_indx
  storage (initial 10m NEXT 10m minextents 1 maxextents 500 pctincrease 0)
/
ALTER TABLE tax_k1_t
  add foreign key (realm_id)
    references realm_owner_t(realm_id)
/
ALTER TABLE tax_k1_t
  add foreign key (user_id)
    references user_t(user_id)
/
ALTER TABLE tax_k1_t add check (entity_type between 0 and 12)
/
ALTER TABLE tax_k1_t add check (partner_type between 0 and 3)
/
ALTER TABLE tax_k1_t add check (foreign_partner between 0 and 1)
/
ALTER TABLE tax_k1_t modify entity_type not null
/
ALTER TABLE tax_k1_t modify partner_type not null
/
ALTER TABLE tax_k1_t modify foreign_partner not null
/

CREATE INDEX tax_1065_realm_i ON tax_1065_t (
  realm_id
)
  storage (initial 10m next 10m minextents 1 maxextents 500 pctincrease 0)
  tablespace realm_indx
/

CREATE INDEX tax_k1_realm_i ON tax_k1_t (
  realm_id
)
  storage (initial 10m next 10m minextents 1 maxextents 500 pctincrease 0)
  tablespace realm_indx
/
');

    my($req) = Bivio::Agent::Request->get_current_or_new;
    my($realm) = Bivio::Biz::Model::RealmOwner->new($req);
    my($sth) = Bivio::SQL::Connection->execute('
            SELECT realm_owner_t.realm_id
            FROM realm_owner_t
            WHERE realm_owner_t.realm_type=?
            ORDER BY realm_owner_t.name',
	    [Bivio::Auth::RealmType::CLUB()->as_sql_param]);
    while (my $row = $sth->fetchrow_arrayref) {
	$realm->unauth_load(realm_id => $row->[0])
		|| die("couldn't load realm ".$row->[0]);
	$req->put(auth_id => $realm->get('realm_id'));

	print(STDERR $realm->get('name')."\n");

	# set tax free interest where appropriate
	print(STDERR "\tupdating tax free interest\n");
	Bivio::Data::EW::ClubImporter->update_tax_free_interest($realm);
    }

    # update all withdrawal fees, changing the sign
    Bivio::SQL::Connection->execute('
            UPDATE entry_t
            SET amount = -amount
            WHERE entry_id in (
                SELECT entry_id
                FROM entry_t
                WHERE entry_type=?)',
	    [Bivio::Type::EntryType::MEMBER_WITHDRAWAL_FEE()->as_sql_param]);

    _upgrade_reinvested_commissions();
    return;
}

# _upgrade_reinvested_commissions()
#
# Fixes the tax category on all reinvested commission.
# Existing records have a tax category of NOT_TAXABLE which isn't correct.
#
sub _upgrade_reinvested_commissions {
    my($sth) = Bivio::SQL::Connection->execute('
            SELECT realm_transaction_t.realm_transaction_id,
                entry_t.tax_category
            FROM realm_transaction_t, entry_t
            WHERE realm_transaction_t.realm_transaction_id
                =entry_t.realm_transaction_id
            AND entry_t.entry_type=?',
	    [Bivio::Type::EntryType->INSTRUMENT_DISTRIBUTION_INVESTMENT
		    ->as_int]);
    while (my $row = $sth->fetchrow_arrayref) {
	my($txn_id, $tax) = @$row;
	Bivio::SQL::Connection->execute('
                UPDATE entry_t
                SET tax_category=?
                WHERE realm_transaction_id=?
                AND entry_type=?',
		[$tax, $txn_id,
			Bivio::Type::EntryType
			->INSTRUMENT_DISTRIBUTION_INVESTMENT_COMMISSION
			->as_int]);
    }
    return;
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
