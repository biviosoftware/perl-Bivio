#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Collection::Attributes;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;

#=VARIABLES

sub main {
    my(@argv) = @_;
    Bivio::IO::Config->initialize(\@argv);

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
#TODO: Change this back to "eq 'upgrade'"
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.  Avo
    &{\&{$method}}();

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::SQL::Connection->commit;

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _do(string sql) : statement
#
# Returns the last statement executed.
#
sub _do {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_constraints(string table, string column)
#
# Drop all the constraints on a particular table and column
#
sub _drop_constraints {
    my($table, $column) = map {uc($_)} @_;
    # Find all constraints on the table
    my($statement) = _do(<<"EOF");
	    SELECT user_cons_columns.constraint_name
	      FROM user_cons_columns, user_constraints
	      WHERE user_cons_columns.column_name = '$column'
	      AND user_cons_columns.table_name = '$table'
	      AND user_constraints.constraint_name
	      = user_cons_columns.constraint_name
              /
EOF
    my(@constraints);
    while (my($name) = $statement->fetchrow_array) {
	push(@constraints, $name);
    }
    $statement->finish;

    # Drop the constraints
    foreach my $c (@constraints) {
	_do("ALTER TABLE $table drop constraint $c
                /");
    }
    return;
}

# _upgrade()
#
# Replace this method with the table/data manipulations.
#
sub _upgrade {

    use Bivio::Auth::RealmType;
    use Bivio::Agent::Request;
    use Bivio::Biz::Model::File;
    use Bivio::Biz::Model::RealmOwner;
    use Bivio::Biz::Model::RealmOwnerList;
    use Bivio::Type::DateTime;
    use Bivio::Type::FileVolume;
    use Bivio::Type::Integer;

    # drop and readd file_t volume constraints, adds expanded volume check
    # to include the EW_IMPORT volume
    _drop_constraints('file_t', 'volume');
    _do('
ALTER TABLE file_t modify volume not null
/
ALTER TABLE file_t add check (volume BETWEEN 1 AND 2)
/
');

    # fix Herly Industries Inc Wts 1999 ticker problem
    Bivio::SQL::Connection->execute("
            UPDATE instrument_t
            SET ticker_symbol='HRLYW'
            WHERE instrument_id = (
                SELECT instrument_id
                FROM mgfs_instrument_t
                WHERE symbol='HRLYW'
            )");

    # add check on ticker so it doesn't happen again
    _do('
ALTER TABLE instrument_t modify ticker_symbol not null
/
');

    # update existing shadow names, add "-1" active flag to end of each
    my($sth) = Bivio::SQL::Connection->execute("
            SELECT name FROM realm_owner_t
            WHERE name like '=%'",
	    []);
    while (my $row = $sth->fetchrow_arrayref) {
	my($name) = $row->[0];
	unless ($name =~ /-\d+$/) {
	    Bivio::SQL::Connection->execute('
                    UPDATE realm_owner_t
                    SET name=?
                    WHERE name=?',
		    [$name.'-1', $name]);
	}
    }

    # add EW_IMPORT file volume to existing clubs
    my($req) = Bivio::Agent::Request->get_current_or_new;
    my($realms) = Bivio::Biz::Model::RealmOwnerList->new($req);
    $realms->unauth_load({
        realm_type => Bivio::Auth::RealmType::CLUB(),
        count => Bivio::Type::Integer->get_max,
    });
    my($realm) = Bivio::Biz::Model::RealmOwner->new($req);
    my($realm_id) = '';
    my($file) = Bivio::Biz::Model::File->new($req);
    while ($realms->next_row) {
        # May have multiple administrators
        next if $realm_id eq $realms->get('RealmOwner.realm_id');
        $realm_id = $realms->get('RealmOwner.realm_id');
        die('failed to load realm ', $realm_id)
                unless $realm->unauth_load(realm_id => $realm_id);
	$req->put(auth_id => $realm_id);

	my($volume) = Bivio::Type::FileVolume::EW_IMPORT();
	my($user_id) = $realms->get('RealmUser.user_id');
	$file->create({
	    file_id => $volume->get_root_directory_id($realm_id),
	    realm_id => $realm_id,
	    volume => $volume,
	    directory_id => undef,
	    name => $volume->get_name.$realm_id,
	    user_id => $user_id,
	    modified_date_time => Bivio::Type::DateTime->now,
	    bytes => 0,
	    is_directory => 1,
	    aux_info => undef,
	    content => undef,
	});
    }

do('
CREATE TABLE lock_t (
  realm_id NUMBER(18),
  type NUMBER(2),
  host VARCHAR2(100),
  process_id NUMBER(9),
  sentinel NUMBER(1),
  creation_date_time DATE
)
/
--
-- lock_t
--
ALTER TABLE lock_t
  add foreign key (realm_id)
    references realm_owner_t(realm_id)
/
ALTER TABLE lock_t
  add primary key(type, realm_id)
  using index tablespace realm_indx
  storage (initial 10m NEXT 10m minextents 1 maxextents 500 pctincrease 0)
/
ALTER TABLE lock_t modify type NOT NULL
/
ALTER TABLE lock_t ADD CHECK (type BETWEEN 1 AND 1)
/
ALTER TABLE lock_t modify host NOT NULL
/
ALTER TABLE lock_t modify process_id NOT NULL
/
ALTER TABLE lock_t modify sentinel NOT NULL
/
ALTER TABLE lock_t ADD CHECK (sentinel BETWEEN 0 AND 1)
/
ALTER TABLE lock_t modify creation_date_time NOT NULL
/
');

    return;
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
