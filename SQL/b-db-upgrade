#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Biz::Model::MGFSInstrument;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::Type::DateTime;

#=VARIABLES
$| = 1;

sub main {
    my(@argv) = @_;
    Bivio::IO::Config->initialize(\@argv);

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.  Avo
    &{\&{$method}}();

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::SQL::Connection->commit;

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _add_column(string table, string column, string sql_type, string value)
#
# Adds a column to the database and sets the default value.  Add constraints or
# indices, add them after this call.
#
sub _add_column {
    my($table, $column, $type, $value) = @_;
    print "Adding $table.$column\n";
    _do_sql("
ALTER TABLE $table
    ADD $column $type
/
");
    return unless defined($value);

    # Insert default values
    print "Inserting default into $table.$column\n";
    _do_sql("
update $table $column = $value
/");

    return;
}

# _do_sql(string sql) : statement
#
# Returns the last statement executed.
#
sub _do_sql {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_column(string table, string column)
#
# Drops the column.
#
sub _drop_column {
    my($table, $column) = @_;
    print "Dropping $table.$column\n";
    _do_sql("
ALTER TABLE $table
    DROP COLUMN $column
/
");
    return;
}

# _drop_constraints(string table, string column) : int
#
# Drop all the constraints on a particular table and column.
# Returns number of constraints dropped.
#
sub _drop_constraints {
    my($table, $column) = map {uc($_)} @_;
    # Find all constraints on the table
    my($statement) = _do_sql(<<"EOF");
	    SELECT user_cons_columns.constraint_name
	      FROM user_cons_columns, user_constraints
	      WHERE user_cons_columns.column_name = '$column'
	      AND user_cons_columns.table_name = '$table'
	      AND user_constraints.constraint_name
	      = user_cons_columns.constraint_name
              /
EOF
    my(@constraints);
    while (my($name) = $statement->fetchrow_array) {
	push(@constraints, $name);
    }
    $statement->finish;

    # Drop the constraints
    foreach my $c (@constraints) {
	_do_sql("ALTER TABLE $table drop constraint $c
                /");
    }
    return int(@constraints);
}

# _fix_mgfs_names(hash_ref name_map)
#
# Takes a map of (bad_name => 'good_name') and updates mgfs_instrument_t
# and instrument_t.
#
sub _fix_mgfs_names {
    my($name_map) = @_;

    my($mgfs_instrument) = Bivio::Biz::Model::MGFSInstrument->new(
	    Bivio::Agent::Request->get_current_or_new);
    foreach my $bad_name (keys(%$name_map)) {
	if ($mgfs_instrument->unsafe_load(name => $bad_name)) {

	    # this will all synchronize with the instrument_t table
	    $mgfs_instrument->update({name => $name_map->{$bad_name}});
	}
	else {
	    print(STDERR "\nmgfs_instrument name '$bad_name' not found\n");
	}
    }
    return;
}

# _modify_column(string table, string column, string type)
#
# Change the type of the column.
#
sub _modify_column {
    my($table, $column, $type) = @_;
    _do_sql("
ALTER TABLE $table MODIFY $column $type
/");
    return;
}

# _upgrade()
#
# Replace this method with the table/data manipulations.
#
sub _upgrade {

    print("\ndeleting all member_allocation_t records");
    _do_sql('
DELETE FROM member_allocation_t
/
');

    print("\nadding member_allocation_t.allocation_type");
    _add_column('member_allocation_t', 'allocation_type', 'NUMBER(2)');

    print("\nre-keying member_allocation_t");
    _do_sql('
ALTER TABLE member_allocation_t DROP CONSTRAINT member_allocation_t1
/
');
    _do_sql('
ALTER TABLE member_allocation_t
  add constraint member_allocation_t1
  primary key(realm_id, user_id, allocation_date, tax_category,
    allocation_type)
  using index tablespace index_1m pctfree 0 initrans 4 storage (freelists 8)
/
');

    print("\nexpanding member_allocation_t tax_cateogry constraint");
    _do_sql('
ALTER TABLE member_allocation_t DROP CONSTRAINT member_allocation_t5
/
');
    _do_sql('
ALTER TABLE member_allocation_t
  add constraint member_allocation_t5
  check (tax_category between 1 and 10
  or tax_category = 100)
/
');

    _upgrade_redo_allocations();
    print("\n*** done ***\n");
    return;
}

# _upgrade_export_info()
#
# Upgrades the legacy import export_info.txt file for every club.
#
sub _upgrade_export_info {

    use Bivio::Auth::Realm;
    use Bivio::Auth::Role;
    use Bivio::Biz::Action::AccountingImport;
    use Bivio::Biz::Model::ClubUserList;
    use Bivio::Biz::Model::File;
    use Bivio::Biz::Model::RealmOwner;
    use Bivio::Biz::Model::RealmUser;
    use Bivio::Data::EW::ConfigurationGenerator;

    my($req) = Bivio::Agent::Request->get_current_or_new;
    my($realm) = Bivio::Biz::Model::RealmOwner->new($req);
    my($user) = Bivio::Biz::Model::RealmOwner->new($req);
    my($file) = Bivio::Biz::Model::File->new($req);
    my($sth) = Bivio::SQL::Connection->execute('
            SELECT file_t.file_id, file_t.realm_id, file_t.user_id
            FROM file_t, realm_owner_t
            WHERE file_t.realm_id=realm_owner_t.realm_id
            AND file_t.name=?
            AND file_t.volume=?
            ORDER BY realm_owner_t.name',
	    ['export_info.txt', Bivio::Type::FileVolume::EW_IMPORT()->as_int]);

    while (my $row = $sth->fetchrow_arrayref) {
	my($file_id, $realm_id, $user_id) = @$row;
	$realm->unauth_load_or_die(realm_id => $realm_id);
	$user->unauth_load_or_die(realm_id => $user_id);
	$req->set_realm(Bivio::Auth::Realm->new($realm));
	$req->set_user($user);

	$file->load(name => 'export_info.txt');
	print("\n".$realm->get('name'));
	_interactive_update_export_info($req, $file);
    }

    print("\n*** done ***\n");
    return;
}

# _interactive_update_export_info(Bivio::Agent::Request req, Bivio::Biz::Model::File file)
#
# Updates the user_id field in the export_info.txt file to the correct
# user.
#
sub _interactive_update_export_info {
    my($req, $file) = @_;
    my($info) = eval(${$file->get('content')});
    my($realm_user) = Bivio::Biz::Model::RealmUser->new($req);

    # essentially:
    # find all invalid user_ids in the export_info
    # iterate invalid user_ids
    # iterate the ClubUserList looking for unmatched users with transactions
    # simple guess on display_name
    # show choices and invalid user info
    # accept choice from console, allowing skip and abort

    my($has_changed) = 0;
    my($matched_users) = {};
    my($unmatched_users) = [];
    foreach my $user (values(%{$info->{members}})) {
	my($user_id) = $user->{user_id};
	if ($realm_user->unsafe_load(user_id => $user_id)) {
	    $matched_users->{$user_id} = 1;
	}
	else {
	    push(@$unmatched_users, $user);
	}
    }

    # all OK
    if (int(@$unmatched_users) == 0) {
	print("\n\tno matching required");
	return 1;
    }

    print("\n");
    my($members) = Bivio::Biz::Model::ClubUserList->new($req);
    $members->load_all;
    foreach my $user (@$unmatched_users) {
    redo:
	# (user_id, member_info)
	my($search_display_name) = uc(($user->{first_name} || '').' '
		.($user->{last_name} || ''));
	my($default_choice) = undef;
	my($current_index) = 0;
	my($match_list) = [];
	$members->reset_cursor;
	while ($members->next_row) {
	    my($user_id, $role) = $members->get(qw(
                    RealmUser.user_id RealmUser.role));
	    next if exists($matched_users->{$user_id});
	    next if $role == Bivio::Auth::Role::GUEST();

	    $realm_user->load(user_id => $user_id);
	    next unless $realm_user->has_transactions;

	    my($phone) = $members->get('Phone.phone') || '';
	    my($member_info) = uc($members->get('RealmOwner.display_name'))
		    .lc(' ('.$phone.")\n"
			    .$members->format_address."\n\n");
	    push(@$match_list, [$user_id, $member_info]);

	    # best guess using display_name
	    # if > 1 hit, then use invalid '-1' value
	    if (uc($members->get('RealmOwner.display_name'))
		    eq $search_display_name) {
		if (defined($default_choice)) {
		    $default_choice = '-1';
		}
		else {
		    $default_choice = $current_index;
		}
	    }
	    $current_index++;
	}
	# give up if no matches available
	next unless int(@$match_list) > 0;

	for (my($i) = 0; $i < int(@$match_list); $i++) {
	    my($match) = $match_list->[$i];
	    print($i.'. '.$match->[1]);
	}
	my($member_info) = '';
	print("match: ".uc(($user->{first_name} || '').' '
		.($user->{last_name} || ''))
		.lc(' ('.($user->{home_phone} || '').")\n"
			.($user->{street1} || '')."\n"
			.($user->{city} || '').' '
			.($user->{state} || '').' '
			.($user->{zip} || '')."\n"));
	print('(s) to skip, (q) to abort ');
	print(", ($default_choice)") if defined($default_choice);
	print(' > ');
	my $choice = <STDIN>;
	if ($choice eq "\n" && defined($default_choice)) {
	    $choice = $default_choice;
	}
	next if $choice eq "s\n";
	exit(-1) if $choice eq "q\n";
	# hacker!
	goto redo unless $choice =~ /^\d+$/;
	goto redo if $choice >= int(@$match_list);

	my($matched_user_id) = $match_list->[$choice]->[0];
	$matched_users->{$matched_user_id} = 1;
	$user->{user_id} = $matched_user_id;
	$has_changed = 1;

	print("---------------------------------------------------------\n\n");
    }

    # save the export_info.txt file (hacked method deletes then recreates it)
    if ($has_changed) {
	my($new_info) = Bivio::Data::EW::ConfigurationGenerator
		->hash_as_string($info);
	# total hacker!
	Bivio::Biz::Action::AccountingImport::_hack_update_file_content(
		$file, \$new_info);
    }
    return;
}

# _upgrade_redo_allocations()
#
# Redo tax allocations for imported clubs.
#
sub _upgrade_redo_allocations {

    use Bivio::Auth::Realm;
    use Bivio::Biz::Accounting::Tax;
    use Bivio::Biz::Accounting::MemberBasis;
    use Bivio::Biz::Model::File;
    use Bivio::Biz::Model::RealmOwner;
    use Bivio::Data::EW::ClubImporter;
    use Bivio::Data::EW::ExportParser;
    use Bivio::Type::Date;
    use Bivio::Type::DateTime;
    use Bivio::Type::EntryType;
    use Bivio::Type::FileVolume;

    # really make sure all allocations are gone
    _do_sql('
DELETE FROM member_allocation_t
/
');

    my($req) = Bivio::Agent::Request->get_current_or_new;

    # delete all MEMBER_LEGACY_UNIT_DISTRIBUTION transactions
    # these will get recreated during import_allocations()
    print("\ndeleting existing legacy unit distributions");
    my($sth) = Bivio::SQL::Connection->execute('
            SELECT realm_transaction_id
            FROM entry_t
            WHERE entry_type=?',
	    [Bivio::Type::EntryType->MEMBER_LEGACY_UNIT_DISTRIBUTION->as_int]);
    while (my $row = $sth->fetchrow_arrayref) {
	my($txn_id) = $row->[0];
	Bivio::SQL::Connection->execute('
                DELETE FROM member_entry_t
                WHERE entry_id IN (
                    SELECT entry_id
                    FROM entry_t
                    WHERE realm_transaction_id=?)',
		[$txn_id]);
	Bivio::SQL::Connection->execute('
                DELETE FROM entry_t
                WHERE realm_transaction_id=?',
		[$txn_id]);
	Bivio::SQL::Connection->execute('
                DELETE FROM realm_transaction_t
                WHERE realm_transaction_id=?',
		[$txn_id]);
    }

    # search EW_IMPORT volume for 'export_info.txt' files
    my($file) = Bivio::Biz::Model::File->new($req);
    my($realm) = Bivio::Biz::Model::RealmOwner->new($req);
    my($auth_user) = Bivio::Biz::Model::RealmOwner->new($req);
    $sth = Bivio::SQL::Connection->execute('
            SELECT file_t.file_id
            FROM file_t, realm_owner_t
            WHERE file_t.realm_id=realm_owner_t.realm_id
            AND file_t.name=?
            AND file_t.volume=?
            ORDER BY realm_owner_t.name',
	    ['export_info.txt', Bivio::Type::FileVolume::EW_IMPORT()->as_int]);
    while (my $row = $sth->fetchrow_arrayref) {

	# foreach export file:
	#  * load the corresponding ncadata.dat file
	#  * set the request's auth_realm and auth_user
	#  * import allocations
	#  * determing withdrawal gains

	my($file_id) = $row->[0];
	$file->unauth_load_or_die(file_id => $file_id);
	my($info) = eval(${$file->get('content')});
	$realm->unauth_load_or_die(realm_id => $file->get('realm_id'));
	$req->set_realm(Bivio::Auth::Realm->new($realm));
	print("\n".$realm->get('name'));

	print("\n\tfinding club admin");
	# get the first admin in the club
	my ($sth2) = Bivio::SQL::Connection->execute('
                SELECT realm_transaction_t.user_id
                FROM realm_transaction_t
                WHERE realm_transaction_t.realm_id=?
                AND realm_transaction_t.date_time=(
                    SELECT MIN(realm_transaction_t.date_time)
                    FROM realm_transaction_t
                    WHERE realm_transaction_t.realm_id=?)',
		[$req->get('auth_id', 'auth_id')]);
	my($user_id);
	while (my $row2 = $sth2->fetchrow_arrayref) {
	    $user_id ||= $row2->[0];
	}
	next unless $user_id;
	$auth_user->unauth_load_or_die(realm_id => $user_id);
	$req->set_user($auth_user);

	$file->load(name => 'ncadata.dat',
		volume => Bivio::Type::FileVolume::EW_IMPORT());
	my($importer) = Bivio::Data::EW::ClubImporter->new(
		Bivio::Data::EW::ExportParser->new($file->get('content')));

	# it will die if the club has cleared the accounting
	# since the last import
	my($die) = Bivio::Die->catch(sub {
	    print("\n\timporting allocations");
	    $importer->import_allocations($info);
	    print("\n\tcalculating withdrawal gains");
	    Bivio::Biz::Accounting::MemberBasis
			->calculate_all_realized_gain($req);

	    # delete allocations for this year (the year isn't completed)
	    my($start, $end) = Bivio::Biz::Accounting::Tax
		    ->get_date_boundary_for_year(Bivio::Type::Date->now);
	    my($_SQL_DATE_VALUE) = Bivio::Type::DateTime->to_sql_value('?');
	    Bivio::SQL::Connection->execute("
                    DELETE FROM member_allocation_t
                    WHERE allocation_date BETWEEN
                        $_SQL_DATE_VALUE AND $_SQL_DATE_VALUE
                    AND realm_id=?",
		    [$start, $end, $req->get('auth_id')]);
	});
	if ($die) {
	    print("\n".$die->get('attrs')->{message});
	}
    }
    return;
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
