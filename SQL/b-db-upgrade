#!perl -w
# Copyright (c) 1999 bivio, LLC.  All rights reserved.
# $Id$
use strict;
my($VERSION) = sprintf('%d.%02d', q$Revision$ =~ /\d+/g);

=head1 NAME

b-db-upgrade - database upgrade

=head1 SYNOPSIS

b-db-upgrade

=head1 DESCRIPTION

B<b-db-upgrade> database upgrade.
This script is the home for database table or data modifications. It stores
a copy of the current version in the database to prevent rerunning the
script.

To install an upgrade, use the magic argument '_upgrade':

    b-db-upgrade _upgrade

To create a new upgrade script, replace the entire contents of the
_upgrade() method and check in the new version.

There is sometimes a lag between scripts installed on the production
system, so create other methods and "chain" them.

=cut

#=IMPORTS
use Bivio::Agent::Request;
use Bivio::Auth::Realm;
use Bivio::Auth::RealmType;
use Bivio::Biz::Model::DbUpgrade;
use Bivio::Biz::Model::MGFSInstrument;
use Bivio::Biz::Model::RealmOwner;
use Bivio::IO::Config;
use Bivio::SQL::Connection;
use Bivio::ShellUtil;
use Bivio::Type::Date;
use Bivio::Type::DateTime;

#=VARIABLES
$| = 1;

sub main {
    my(@argv) = @_;

    # want to avoid accidentally running this script
    my($method) = @argv;
    _usage("missing or bad method")
	    unless $method && $method  =~ /^_upgrade/;

    my($req) = Bivio::Agent::Request->get_current_or_new();
    my($upgrade) = Bivio::Biz::Model::DbUpgrade->new($req);
    if ($upgrade->unauth_load(version => $VERSION)) {
	_usage("$VERSION already ran");
    }

    # Sometimes there may be multiple upgrades and they need to be installed at
    # different times (on test system).  Probably good to keep this flexibility
    # in the tool for now.
    &{\&{$method}}($req);

    # creates a completion entry in db to prevent re-running
    $upgrade->create({
	version => $VERSION,
	run_date_time => Bivio::Type::DateTime->now
    });
    Bivio::Agent::Task->commit($req);

    return 1;
}

main(@ARGV);

#=PRIVATE METHODS

# _add_column(string table, string column, string sql_type, string value)
#
# Adds a column to the database and sets the default value.  Add constraints or
# indices, add them after this call.
#
sub _add_column {
    my($table, $column, $type, $value) = @_;
    print "Adding $table.$column\n";
    _do_sql("
ALTER TABLE $table
    ADD $column $type
/
");
    return unless defined($value);

    # Insert default values
    print "Inserting default into $table.$column\n";
    _do_sql("
update $table set $column = $value
/");

    return;
}

# _do_sql(string sql) : statement
#
# Returns the last statement executed.
#
sub _do_sql {
    my($sql) = @_;
    my($statement);
    my($s) = '';
    foreach my $line (split(/\n/, $sql)) {
	# Skip comments and blanks
	next if $line =~ /^\s*--|^\s*$/;

	# Execute statement if '/' found
	if ($line =~ /^\s*\/\s*$/) {
	    $statement = Bivio::SQL::Connection->execute($s);
	    $s = '';
	    next;
	}

	# Build up statement
	$s .= $line."\n";
    }
    die("$s: left over statement") if $s;
    return $statement;
}

# _drop_column(string table, string column)
#
# Drops the column.
#
sub _drop_column {
    my($table, $column) = @_;
    print "Dropping $table.$column\n";
    _do_sql("
ALTER TABLE $table
    DROP COLUMN $column
/
");
    return;
}

# _drop_constraints(string table, string column) : int
#
# Drop all the constraints on a particular table and column.
# Returns number of constraints dropped.
#
sub _drop_constraints {
    my($table, $column) = map {uc($_)} @_;
    # Find all constraints on the table
    my($statement) = _do_sql(<<"EOF");
	    SELECT user_cons_columns.constraint_name
	      FROM user_cons_columns, user_constraints
	      WHERE user_cons_columns.column_name = '$column'
	      AND user_cons_columns.table_name = '$table'
	      AND user_constraints.constraint_name
	      = user_cons_columns.constraint_name
              /
EOF
    my(@constraints);
    while (my($name) = $statement->fetchrow_array) {
	push(@constraints, $name);
    }
    $statement->finish;

    # Drop the constraints
    foreach my $c (@constraints) {
	_do_sql("ALTER TABLE $table drop constraint $c
                /");
    }
    return int(@constraints);
}

# _fix_mgfs_names(hash_ref name_map)
#
# Takes a map of (bad_name => 'good_name') and updates mgfs_instrument_t
# and instrument_t.
#
sub _fix_mgfs_names {
    my($name_map) = @_;

    my($mgfs_instrument) = Bivio::Biz::Model::MGFSInstrument->new(
	    Bivio::Agent::Request->get_current_or_new);
    foreach my $bad_name (keys(%$name_map)) {
	if ($mgfs_instrument->unsafe_load(name => $bad_name)) {

	    # this will all synchronize with the instrument_t table
	    $mgfs_instrument->update({name => $name_map->{$bad_name}});
	}
	else {
	    print(STDERR "\nmgfs_instrument name '$bad_name' not found\n");
	}
    }
    return;
}

# _modify_column(string table, string column, string type)
#
# Change the type of the column.
#
sub _modify_column {
    my($table, $column, $type) = @_;
    _do_sql("
ALTER TABLE $table MODIFY $column $type
/");
    return;
}

# _sqlplus(string db_login, string actions) : string_ref
#
# Runs I<actions> in sqlplus with I<db_login>.
# Returns result of the execution.
#
# I<actions> will have a semicolon (;) appended to it.
#
# If any of I<actions> fails, will rollback and exit.
#
sub _sqlplus {
    my($db_login, $actions) = @_;
    my($res) = Bivio::ShellUtil::piped_exec(undef, 'su - oracle -c sqlplus',
            <<"EOF");
$db_login
set linesize 10000
set pagesize 10000
whenever sqlerror exit sql.sqlcode rollback
whenever oserror exit sql.sqlcode rollback
$actions;
disconnect
exit
EOF
    return $res;
}

# _upgrade(Bivio::Agent::Request req)
#
# Replace this method with the table/data manipulations.
#
sub _upgrade {
    my($req) = @_;

    _upgrade_instrument_type();
    _upgrade_csi_tables();
    _upgrade_recreate_ticker_symbol_index();
    print("\n*** done ***\n");
    return;
}

# _upgrade_csi_tables() : 
#
# Create CSI tables
#
sub _upgrade_csi_tables {
    print("Creating CSI tables\n");
    _do_sql(<<'EOF');
CREATE TABLE instrument_valuation_t (
  instrument_id NUMBER(18),
  closing_date DATE,
  closing_price NUMBER(23,6),
  constraint instrument_valuation_t1 primary key(instrument_id, closing_date)
)
  organization INDEX COMPRESS 1 tablespace index_64m
  pctfree 10 initrans 2 storage (freelists 1)
/
ALTER TABLE instrument_valuation_t modify instrument_id not null
/
ALTER TABLE instrument_valuation_t modify closing_date not null
/
ALTER TABLE instrument_valuation_t modify closing_price not null
/
CREATE TABLE csi_distribution_t (
  csi_id NUMBER(9),
  distribution_date DATE,
  distribution_type CHAR(2),
  amount NUMBER(23,6)
)
  tablespace data_1m
  pctfree 5 pctused 90 initrans 1 storage (freelists 1 pctincrease 0)
/

CREATE TABLE csi_fact_sheet_t (
  csi_id NUMBER(9),
  fact_date DATE,
  fact_op CHAR(2),
  ticker_symbol VARCHAR2(30),
  name VARCHAR2(100),
  conversion_factor NUMBER(20,3),
  exchange_name VARCHAR2(30)
)
  tablespace data_1m
  pctfree 5 pctused 90 initrans 1 storage (freelists 1 pctincrease 0)
/

CREATE TABLE csi_import_t (
  file_name VARCHAR2(30),
  import_date DATE
)
  tablespace data_1m
  pctfree 5 pctused 90 initrans 1 storage (freelists 1 pctincrease 0)
/

CREATE TABLE csi_instrument_t (
  csi_id NUMBER(9),
  instrument_id NUMBER(18),
  instrument_type NUMBER(2)
)
  tablespace data_1m
  pctfree 5 pctused 90 initrans 1 storage (freelists 1 pctincrease 0)
/

CREATE TABLE csi_mutual_fund_t (
  csi_id NUMBER(9),
  price_date DATE,
  net_asset_value NUMBER(23,6),
  ask_price NUMBER(23,6)
)
  tablespace data_64m
  pctfree 5 pctused 90 initrans 1 storage (freelists 1 pctincrease 0)
/

CREATE TABLE csi_split_t (
  csi_id NUMBER(9),
  split_date DATE,
  new_shares NUMBER(9),
  old_shares NUMBER(9)
)
  tablespace data_1m
  pctfree 5 pctused 90 initrans 1 storage (freelists 1 pctincrease 0)
/

CREATE TABLE csi_stock_price_t (
  csi_id NUMBER(9),
  price_date DATE,
  open NUMBER(23,6),
  high NUMBER(23,6),
  low NUMBER(23,6),
  close NUMBER(23,6),
  volume NUMBER(20,3)
)
  tablespace data_64m
  pctfree 5 pctused 90 initrans 1 storage (freelists 1 pctincrease 0)
/
ALTER TABLE csi_distribution_t
  add constraint csi_distribution_t1
  primary key(csi_id, distribution_date, distribution_type)
  using index tablespace index_1m pctfree 10 initrans 2 storage (freelists 1)
/
ALTER TABLE csi_fact_sheet_t
  add constraint csi_fact_sheet_t1
  primary key(csi_id, fact_date)
  using index tablespace index_1m pctfree 10 initrans 2 storage (freelists 1)
/
ALTER TABLE csi_import_t
  add constraint csi_import_t1
  primary key (file_name)
  using index tablespace index_1m pctfree 10 initrans 2 storage (freelists 1)
/
ALTER TABLE csi_instrument_t
  add constraint csi_instrument_t1
  primary key (csi_id)
  using index tablespace index_1m pctfree 10 initrans 2 storage (freelists 1)
/
ALTER TABLE csi_mutual_fund_t
  add constraint csi_mutual_fund_t1
  primary key (csi_id, price_date)
  using index tablespace index_64m pctfree 10 initrans 2 storage (freelists 1)
/
ALTER TABLE csi_split_t
  add constraint csi_split_t1
  primary key(csi_id, split_date)
  using index tablespace index_1m pctfree 10 initrans 2 storage (freelists 1)
/
ALTER TABLE csi_stock_price_t
  add constraint csi_stock_price_t1
  primary key(csi_id, price_date)
  using index tablespace index_64m pctfree 10 initrans 2 storage (freelists 1)
/

----------------------------------------------------------------
-- Non-Primary Key Constraints
----------------------------------------------------------------
--
-- csi_distribution_t
--
ALTER TABLE csi_distribution_t modify csi_id not null
/
ALTER TABLE csi_distribution_t
  add constraint csi_distribution_t2
  foreign key (csi_id)
  references csi_instrument_t
/
ALTER TABLE csi_distribution_t modify distribution_date not null
/
ALTER TABLE csi_distribution_t
  add constraint csi_distribution_t3
  check (distribution_type between 1 and 2)
/
ALTER TABLE csi_distribution_t modify amount not null
/

--
-- csi_fact_sheet_t
--
ALTER TABLE csi_fact_sheet_t modify csi_id not null
/
ALTER TABLE csi_fact_sheet_t
  add constraint csi_fact_sheet_t2
  foreign key (csi_id)
  references csi_instrument_t
/
ALTER TABLE csi_fact_sheet_t modify fact_date not null
/
ALTER TABLE csi_fact_sheet_t
  add constraint csi_fact_sheet_t3
  check (fact_op between 1 and 3)
/
ALTER TABLE csi_fact_sheet_t modify ticker_symbol not null
/
ALTER TABLE csi_fact_sheet_t modify name not null
/
ALTER TABLE csi_fact_sheet_t modify conversion_factor not null
/
ALTER TABLE csi_fact_sheet_t modify exchange_name not null
/

--
-- csi_import_t
--
ALTER TABLE csi_import_t modify file_name not null
/
ALTER TABLE csi_import_t modify import_date not null
/

--
-- csi_instrument_t
--
ALTER TABLE csi_instrument_t modify csi_id not null
/
ALTER TABLE csi_instrument_t
  add constraint csi_instrument_t2
  foreign key (instrument_id)
  references instrument_t
/
ALTER TABLE csi_instrument_t
  add constraint csi_instrument_t3
  check (instrument_type between 1 and 4)
/

--
-- csi_mutual_fund_t
--
ALTER TABLE csi_mutual_fund_t modify csi_id not null
/
ALTER TABLE csi_mutual_fund_t
  add constraint csi_mutual_fund_t2
  foreign key (csi_id)
  references csi_instrument_t
/
ALTER TABLE csi_mutual_fund_t modify price_date not null
/
ALTER TABLE csi_mutual_fund_t modify net_asset_value not null
/
ALTER TABLE csi_mutual_fund_t modify ask_price not null
/

--
-- csi_split_t
--
ALTER TABLE csi_split_t modify csi_id not null
/
ALTER TABLE csi_split_t
  add constraint csi_split_t2
  foreign key (csi_id)
  references csi_instrument_t(csi_id)
/
ALTER TABLE csi_split_t modify split_date not null
/
ALTER TABLE csi_split_t modify new_shares not null
/
ALTER TABLE csi_split_t modify old_shares not null
/

--
-- csi_stock_price_t
--
ALTER TABLE csi_stock_price_t modify csi_id not null
/
ALTER TABLE csi_stock_price_t
  add constraint csi_stock_price_t2
  foreign key (csi_id)
  references csi_instrument_t(csi_id)
/
ALTER TABLE csi_stock_price_t modify price_date not null
/
ALTER TABLE csi_stock_price_t modify open not null
/
ALTER TABLE csi_stock_price_t modify high not null
/
ALTER TABLE csi_stock_price_t modify low not null
/
ALTER TABLE csi_stock_price_t modify close not null
/
ALTER TABLE csi_stock_price_t modify volume not null
/
EOF
    return;
}

# _upgrade_instrument_type()
#
# Extend instrument_type constraint
#
sub _upgrade_instrument_type {
    print("Upgrading instrument_type\n");
    _do_sql(<<'EOF');
ALTER TABLE realm_instrument_t DROP constraint realm_instrument_t8
/
ALTER TABLE realm_instrument_t
  add constraint realm_instrument_t8
  check (instrument_type between 1 and 4)
/
ALTER TABLE instrument_t DROP constraint instrument_t3
/
ALTER TABLE instrument_t
  add constraint instrument_t3
  check (instrument_type between 1 and 4)
/
EOF
    return;
}

# _upgrade_recreate_ticker_symbol_index() : 
#
# ticker_symbol must be unique
#
sub _upgrade_recreate_ticker_symbol_index {
    _do_sql(<<'EOF');
DROP INDEX instrument_t7
/
CREATE UNIQUE INDEX instrument_t7 ON instrument_t (
  ticker_symbol
)
  tablespace index_1m
  pctfree 50 initrans 2 storage (freelists 1)
/
EOF
    return;
}

# _usage(array message)
#
# Print a message and terminate
sub _usage {
    my($msg) = join('', @_);
    print STDERR <<"EOF";
$0: $msg
usage: $0 _upgrade
EOF
    exit(1);
}

=head1 SEE ALSO

Bivio::IO::Config

=head1 COPYRIGHT

Copyright (c) 1999 bivio, LLC.  All rights reserved.

=head1 VERSION

$Id$

=cut

#Local Variables:
#mode:cperl
#End:
